From be985c24dca7a58007924c4017ff3792bd8329f9 Mon Sep 17 00:00:00 2001
From: Lars Wendler <polynomial-c@gentoo.org>
Date: Wed, 14 Apr 2021 14:41:47 +0200
Subject: [PATCH] Revert "checkpath: remove extra slashes from paths" This
 reverts commit 6219d87071d07acf4d6b3e99ec58134acf129d8e.

Revert "src/rc/checkpath.c: replace mkdir() with mkdirat()."
This reverts commit 00ea2166081856774f24f7243126f701c7fe6db9.

Revert "src/rc/checkpath.c: fix typo "synbolic" -> "symbolic"."
This reverts commit ac7ca6d901d72b1bc4ed13be5438e825c07fc0da.

Revert "checkpath: fix CVE-2018-21269"
This reverts commit b6fef599bf8493480664b766040fa9b0d4b1e335.
---
 man/openrc-run.8   |   6 --
 src/rc/checkpath.c | 138 ++++-----------------------------------------
 2 files changed, 10 insertions(+), 134 deletions(-)

diff --git a/man/openrc-run.8 b/man/openrc-run.8
index ec4b88de..1102daaa 100644
--- a/man/openrc-run.8
+++ b/man/openrc-run.8
@@ -461,7 +461,6 @@ Mark the service as inactive.
 .Op Fl p , -pipe
 .Op Fl m , -mode Ar mode
 .Op Fl o , -owner Ar owner
-.Op Fl s , -symlinks
 .Op Fl W , -writable
 .Op Fl q , -quiet
 .Ar path ...
@@ -482,11 +481,6 @@ or with names, and are separated by a colon.
 The truncate options (-D and -F) cause the directory or file to be
 cleared of all contents.
 .Pp
-If -s is not specified on a non-linux platform, checkpath will refuse to
-allow non-terminal symbolic links to exist in the path. This is for
-security reasons so that a non-root user can't create a symbolic link to
-a root-owned file and take ownership of that file.
-.Pp
 If -W is specified, checkpath checks to see if the first path given on
 the command line is writable.  This is different from how the test
 command in the shell works, because it also checks to make sure the file
diff --git a/src/rc/checkpath.c b/src/rc/checkpath.c
index 48275ca9..448c9cf8 100644
--- a/src/rc/checkpath.c
+++ b/src/rc/checkpath.c
@@ -16,7 +16,6 @@
  *    except according to the terms contained in the LICENSE file.
  */
 
-#define _GNU_SOURCE
 #include <sys/types.h>
 #include <sys/stat.h>
 
@@ -24,7 +23,6 @@
 #include <fcntl.h>
 #include <getopt.h>
 #include <grp.h>
-#include <libgen.h>
 #include <pwd.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -46,7 +44,7 @@ typedef enum {
 
 const char *applet = NULL;
 const char *extraopts ="path1 [path2] [...]";
-const char *getoptstring = "dDfFpm:o:sW" getoptstring_COMMON;
+const char *getoptstring = "dDfFpm:o:W" getoptstring_COMMON;
 const struct option longopts[] = {
 	{ "directory",          0, NULL, 'd'},
 	{ "directory-truncate", 0, NULL, 'D'},
@@ -55,7 +53,6 @@ const struct option longopts[] = {
 	{ "pipe",               0, NULL, 'p'},
 	{ "mode",               1, NULL, 'm'},
 	{ "owner",              1, NULL, 'o'},
-	{ "symlinks",           0, NULL, 's'},
 	{ "writable",           0, NULL, 'W'},
 	longopts_COMMON
 };
@@ -67,118 +64,15 @@ const char * const longopts_help[] = {
 	"Create a named pipe (FIFO) if not exists",
 	"Mode to check",
 	"Owner to check (user:group)",
-	"follow symbolic links (irrelivent on linux)",
 	"Check whether the path is writable or not",
 	longopts_help_COMMON
 };
 const char *usagestring = NULL;
 
-static int get_dirfd(char *path, bool symlinks) {
-	char *ch;
-	char *item;
-	char *linkpath = NULL;
-	char *path_dupe;
-	char *str;
-	int components = 0;
-	int dirfd;
-	int flags = 0;
-	int new_dirfd;
-	struct stat st;
-	ssize_t linksize;
-
-	if (!path || *path != '/')
-		eerrorx("%s: empty or relative path", applet);
-	dirfd = openat(dirfd, "/", O_RDONLY);
-	if (dirfd == -1)
-		eerrorx("%s: unable to open the root directory: %s",
-				applet, strerror(errno));
-	ch = path;
-	while (*ch) {
-		if (*ch == '/')
-			components++;
-		ch++;
-	}
-	path_dupe = xstrdup(path);
-	item = strtok(path_dupe, "/");
-#ifdef O_PATH
-	flags |= O_PATH;
-#endif
-	if (!symlinks)
-		flags |= O_NOFOLLOW;
-	flags |= O_RDONLY;
-	while (dirfd > 0 && item && components > 1) {
-		str = xstrdup(linkpath ? linkpath : item);
-		new_dirfd = openat(dirfd, str, flags);
-		if (new_dirfd == -1)
-			eerrorx("%s: %s: could not open %s: %s", applet, path, str,
-					strerror(errno));
-		if (fstat(new_dirfd, &st) == -1)
-			eerrorx("%s: %s: unable to stat %s: %s", applet, path, item,
-					strerror(errno));
-		if (S_ISLNK(st.st_mode) ) {
-			if (st.st_uid != 0)
-				eerrorx("%s: %s: symbolic link %s not owned by root",
-						applet, path, str);
-			linksize = st.st_size+1;
-			if (linkpath)
-				free(linkpath);
-			linkpath = xmalloc(linksize);
-			memset(linkpath, 0, linksize);
-			if (readlinkat(new_dirfd, "", linkpath, linksize) != st.st_size)
-				eerrorx("%s: symbolic link destination changed", applet);
-			/*
-			 * now follow the symlink.
-			 */
-			close(new_dirfd);
-		} else {
-			close(dirfd);
-			dirfd = new_dirfd;
-			free(linkpath);
-			linkpath = NULL;
-		}
-		item = strtok(NULL, "/");
-		components--;
-	}
-	free(path_dupe);
-	free(linkpath);
-	return dirfd;
-}
-
-static char *clean_path(char *path)
-{
-	char *ch;
-	char *ch2;
-	char *str;
-	str = xmalloc(strlen(path));
-	ch = path;
-	ch2 = str;
-	while (true) {
-		*ch2 = *ch;
-		ch++;
-		ch2++;
-		if (!*(ch-1))
-			break;
-		while (*(ch - 1) == '/' && *ch == '/')
-			ch++;
-	}
-	/* get rid of trailing / characters */
-	while ((ch = strrchr(str, '/'))) {
-		if (ch == str)
-			break;
-		if (!*(ch+1))
-			*ch = 0;
-		else
-			break;
-	}
-	return str;
-}
-
 static int do_check(char *path, uid_t uid, gid_t gid, mode_t mode,
-	inode_t type, bool trunc, bool chowner, bool symlinks, bool selinux_on)
+	inode_t type, bool trunc, bool chowner, bool selinux_on)
 {
 	struct stat st;
-	char *name = NULL;
-	int dirfd;
 	int fd;
 	int flags;
 	int r;
@@ -199,16 +93,14 @@ static int do_check(char *path, uid_t uid, gid_t gid, mode_t mode,
 #endif
 	if (trunc)
 		flags |= O_TRUNC;
-	xasprintf(&name, "%s", basename_c(path));
-	dirfd = get_dirfd(path, symlinks);
-	readfd = openat(dirfd, name, readflags);
+	readfd = open(path, readflags);
 	if (readfd == -1 || (type == inode_file && trunc)) {
 		if (type == inode_file) {
 			einfo("%s: creating file", path);
 			if (!mode) /* 664 */
 				mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH;
 			u = umask(0);
-			fd = openat(dirfd, name, flags, mode);
+			fd = open(path, flags, mode);
 			umask(u);
 			if (fd == -1) {
 				eerror("%s: open: %s", applet, strerror(errno));
@@ -223,14 +115,14 @@ static int do_check(char *path, uid_t uid, gid_t gid, mode_t mode,
 				mode = S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH;
 			u = umask(0);
 			/* We do not recursively create parents */
-			r = mkdirat(dirfd, name, mode);
+			r = mkdir(path, mode);
 			umask(u);
 			if (r == -1 && errno != EEXIST) {
-				eerror("%s: mkdirat: %s", applet,
+				eerror("%s: mkdir: %s", applet,
 				    strerror (errno));
 				return -1;
 			}
-			readfd = openat(dirfd, name, readflags);
+			readfd = open(path, readflags);
 			if (readfd == -1) {
 				eerror("%s: unable to open directory: %s", applet,
 						strerror(errno));
@@ -248,7 +140,7 @@ static int do_check(char *path, uid_t uid, gid_t gid, mode_t mode,
 				    strerror (errno));
 				return -1;
 			}
-			readfd = openat(dirfd, name, readflags);
+			readfd = open(path, readflags);
 			if (readfd == -1) {
 				eerror("%s: unable to open fifo: %s", applet,
 						strerror(errno));
@@ -367,10 +259,8 @@ int main(int argc, char **argv)
 	int retval = EXIT_SUCCESS;
 	bool trunc = false;
 	bool chowner = false;
-	bool symlinks = false;
 	bool writable = false;
 	bool selinux_on = false;
-	char *path = NULL;
 
 	applet = basename_c(argv[0]);
 	while ((opt = getopt_long(argc, argv, getoptstring,
@@ -403,11 +293,6 @@ int main(int argc, char **argv)
 				eerrorx("%s: owner `%s' not found",
 				    applet, optarg);
 			break;
-		case 's':
-#ifndef O_PATH
-			symlinks = true;
-#endif
-			break;
 		case 'W':
 			writable = true;
 			break;
@@ -433,14 +318,11 @@ int main(int argc, char **argv)
 		selinux_on = true;
 
 	while (optind < argc) {
-		path = clean_path(argv[optind]);
 		if (writable)
-			exit(!is_writable(path));
-		if (do_check(path, uid, gid, mode, type, trunc, chowner,
-					symlinks, selinux_on))
+			exit(!is_writable(argv[optind]));
+		if (do_check(argv[optind], uid, gid, mode, type, trunc, chowner, selinux_on))
 			retval = EXIT_FAILURE;
 		optind++;
-		free(path);
 	}
 
 	if (selinux_on)
-- 
2.31.1

