diff --git a/HPN-README b/HPN-README
new file mode 100644
index 00000000..2ef5a44a
--- /dev/null
+++ b/HPN-README
@@ -0,0 +1,130 @@
+Notes:
+
+MULTI-THREADED CIPHER:
+The AES cipher in CTR mode has been multithreaded (MTR-AES-CTR). This will allow ssh installations
+on hosts with multiple cores to use more than one processing core during encryption.
+Tests have show significant throughput performance increases when using MTR-AES-CTR up
+to and including a full gigabit per second on quad core systems. It should be possible to
+achieve full line rate on dual core systems but OS and data management overhead makes this
+more difficult to achieve. The cipher stream from MTR-AES-CTR is entirely compatible with single
+thread AES-CTR (ST-AES-CTR) implementations and should be 100% backward compatible. Optimal
+performance requires the MTR-AES-CTR mode be enabled on both ends of the connection.
+The MTR-AES-CTR replaces ST-AES-CTR and is used in exactly the same way with the same
+nomenclature.
+Use examples:
+		ssh -caes128-ctr you@host.com
+		scp -oCipher=aes256-ctr file you@host.com:~/file
+
+NONE CIPHER:
+To use the NONE option you must have the NoneEnabled switch set on the server and
+you *must* have *both* NoneEnabled and NoneSwitch set to yes on the client. The NONE
+feature works with ALL ssh subsystems (as far as we can tell) *AS LONG AS* a tty is not
+spawned. If a user uses the -T switch to prevent a tty being created the NONE cipher will
+be disabled.
+
+The performance increase will only be as good as the network and TCP stack tuning
+on the reciever side of the connection allows. As a rule of thumb a user will need
+at least 10Mb/s connection with a 100ms RTT to see a doubling of performance. The
+HPN-SSH home page describes this in greater detail.
+
+http://www.psc.edu/networking/projects/hpn-ssh
+
+BUFFER SIZES:
+
+If HPN is disabled the receive buffer size will be set to the
+OpenSSH default of 64K.
+
+If an HPN system connects to a nonHPN system the receive buffer will
+be set to the HPNBufferSize value. The default is 2MB but user adjustable.
+
+If an HPN to HPN connection is established a number of different things might
+happen based on the user options and conditions.
+
+Conditions: HPNBufferSize NOT Set, TCPRcvBufPoll enabled, TCPRcvBuf NOT Set
+HPN Buffer Size = up to 64MB
+This is the default state. The HPN buffer size will grow to a maximum of 64MB
+as the TCP receive buffer grows. The maximum HPN Buffer size of 64MB is
+geared towards 10GigE transcontinental connections.
+
+Conditions: HPNBufferSize NOT Set, TCPRcvBufPoll disabled, TCPRcvBuf NOT Set
+HPN Buffer Size = TCP receive buffer value.
+Users on non-autotuning systesm should disable TCPRcvBufPoll in the
+ssh_cofig and sshd_config
+
+Conditions: HPNBufferSize SET, TCPRcvBufPoll disabled, TCPRcvBuf NOT Set
+HPN Buffer Size = minmum of TCP receive buffer and HPNBufferSize.
+This would be the system defined TCP receive buffer (RWIN).
+
+Conditions: HPNBufferSize SET, TCPRcvBufPoll disabled, TCPRcvBuf SET
+HPN Buffer Size = minmum of TCPRcvBuf and HPNBufferSize.
+Generally there is no need to set both.
+
+Conditions: HPNBufferSize SET, TCPRcvBufPoll enabled, TCPRcvBuf NOT Set
+HPN Buffer Size = grows to HPNBufferSize
+The buffer will grow up to the maximum size specified here.
+
+Conditions: HPNBufferSize SET, TCPRcvBufPoll enabled, TCPRcvBuf SET
+HPN Buffer Size = minmum of TCPRcvBuf and HPNBufferSize.
+Generally there is no need to set both of these, especially on autotuning
+systems. However, if the users wishes to override the autotuning this would be
+one way to do it.
+
+Conditions: HPNBufferSize NOT Set, TCPRcvBufPoll enabled, TCPRcvBuf SET
+HPN Buffer Size = TCPRcvBuf.
+This will override autotuning and set the TCP recieve buffer to the user defined
+value.
+
+
+HPN Specific Configuration options
+
+TcpRcvBuf=[int]KB client
+      set the TCP socket receive buffer to n Kilobytes. It can be set up to the
+maximum socket size allowed by the system. This is useful in situations where
+the tcp receive window is set low but the maximum buffer size is set
+higher (as is typical). This works on a per TCP connection basis. You can also
+use this to artifically limit the transfer rate of the connection. In these
+cases the throughput will be no more than n/RTT. The minimum buffer size is 1KB.
+Default is the current system wide tcp receive buffer size.
+
+TcpRcvBufPoll=[yes/no] client/server
+      enable of disable the polling of the tcp receive buffer through the life
+of the connection. You would want to make sure that this option is enabled
+for systems making use of autotuning kernels (linux 2.4.24+, 2.6, MS Vista)
+default is yes.
+
+NoneEnabled=[yes/no] client/server
+      enable or disable the use of the None cipher. Care must always be used
+when enabling this as it will allow users to send data in the clear. However,
+it is important to note that authentication information remains encrypted
+even if this option is enabled. Set to no by default.
+
+NoneSwitch=[yes/no] client
+     Switch the encryption cipher being used to the None cipher after
+authentication takes place. NoneEnabled must be enabled on both the client
+and server side of the connection. When the connection switches to the NONE
+cipher a warning is sent to STDERR. The connection attempt will fail with an
+error if a client requests a NoneSwitch from the server that does not explicitly
+have NoneEnabled set to yes. Note: The NONE cipher cannot be used in
+interactive (shell) sessions and it will fail silently. Set to no by default.
+
+HPNDisabled=[yes/no] client/server
+     In some situations, such as transfers on a local area network, the impact
+of the HPN code produces a net decrease in performance. In these cases it is
+helpful to disable the HPN functionality. By default HPNDisabled is set to no.
+
+HPNBufferSize=[int]KB client/server
+     This is the default buffer size the HPN functionality uses when interacting
+with nonHPN SSH installations. Conceptually this is similar to the TcpRcvBuf
+option as applied to the internal SSH flow control. This value can range from
+1KB to 64MB (1-65536). Use of oversized or undersized buffers can cause performance
+problems depending on the length of the network path. The default size of this buffer
+is 2MB.
+
+
+Credits: This patch was conceived, designed, and led by Chris Rapier (rapier@psc.edu)
+         The majority of the actual coding for versions up to HPN12v1 was performed
+         by Michael Stevens (mstevens@andrew.cmu.edu). The MT-AES-CTR cipher was
+         implemented by Ben Bennet (ben@psc.edu) and improved by Mike Tasota
+         (tasota@gmail.com) an NSF REU grant recipient for 2013.
+         This work was financed, in part, by Cisco System, Inc., the National
+         Library of Medicine, and the National Science Foundation.
diff --git a/Makefile.in b/Makefile.in
index 2385c62a..80906fcd 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -42,7 +42,7 @@ CC=@CC@
 LD=@LD@
 CFLAGS=@CFLAGS@
 CPPFLAGS=-I. -I$(srcdir) @CPPFLAGS@ $(PATHS) @DEFS@
-LIBS=@LIBS@
+LIBS=@LIBS@ -lpthread
 K5LIBS=@K5LIBS@
 GSSLIBS=@GSSLIBS@
 SSHLIBS=@SSHLIBS@
@@ -86,7 +86,7 @@ LIBOPENSSH_OBJS=\
 LIBSSH_OBJS=${LIBOPENSSH_OBJS} \
 	authfd.o authfile.o \
 	canohost.o channels.o cipher.o cipher-aes.o cipher-aesctr.o \
-	cipher-ctr.o cleanup.o \
+	cipher-ctr.o cleanup.o cipher-ctr-mt.o \
 	compat.o crc32.o fatal.o hostfile.o \
 	log.o match.o moduli.o nchan.o packet.o opacket.o \
 	readpass.o ttymodes.o xmalloc.o addrmatch.o \
diff --git a/auth-pam.c b/auth-pam.c
index 8c013836..5ff8805c 100644
--- a/auth-pam.c
+++ b/auth-pam.c
@@ -128,6 +128,12 @@ extern u_int utmp_len;
 typedef pthread_t sp_pthread_t;
 #else
 typedef pid_t sp_pthread_t;
+#if OPENSSL_VERSION_NUMBER <= 0x10100000UL
+# define pthread_create(a, b, c, d)    _ssh_compat_pthread_create(a, b, c, d)
+# define pthread_exit(a)               _ssh_compat_pthread_exit(a)
+# define pthread_cancel(a)             _ssh_compat_pthread_cancel(a)
+# define pthread_join(a, b)            _ssh_compat_pthread_join(a, b)
+#endif
 #endif
 
 struct pam_ctxt {
diff --git a/auth2.c b/auth2.c
index ab879589..cf534a1a 100644
--- a/auth2.c
+++ b/auth2.c
@@ -52,6 +52,7 @@
 #include "pathnames.h"
 #include "sshbuf.h"
 #include "ssherr.h"
+#include "canohost.h"
 
 #ifdef GSSAPI
 #include "ssh-gss.h"
@@ -77,6 +78,8 @@ extern Authmethod method_hostbased;
 extern Authmethod method_gssapi;
 #endif
 
+static int log_flag = 0;
+
 Authmethod *authmethods[] = {
 	&method_none,
 	&method_pubkey,
@@ -266,6 +269,11 @@ input_userauth_request(int type, u_int32_t seq, struct ssh *ssh)
 	service = packet_get_cstring(NULL);
 	method = packet_get_cstring(NULL);
 	debug("userauth-request for user %s service %s method %s", user, service, method);
+	if (!log_flag) {
+		logit("SSH: Server;Ltype: Authname;Remote: %s-%d;Name: %s",
+		      ssh_remote_ipaddr(ssh), ssh_remote_port(ssh), user);
+		log_flag = 1;
+	}
 	debug("attempt %d failures %d", authctxt->attempt, authctxt->failures);
 
 	if ((style = strchr(user, ':')) != NULL)
diff --git a/canohost.h b/canohost.h
index 26d62855..25b25992 100644
--- a/canohost.h
+++ b/canohost.h
@@ -19,7 +19,7 @@ char		*get_peer_ipaddr(int);
 int		 get_peer_port(int);
 char		*get_local_ipaddr(int);
 char		*get_local_name(int);
-int		get_local_port(int);
+int		 get_local_port(int);
 
 #endif /* _CANOHOST_H */
 
diff --git a/channels.c b/channels.c
index e90f7fea..e01601e9 100644
--- a/channels.c
+++ b/channels.c
@@ -220,6 +220,10 @@ static int rdynamic_connect_finish(struct ssh *, Channel *);
 /* Setup helper */
 static void channel_handler_init(struct ssh_channels *sc);
 
+
+static int hpn_disabled = 0;
+static int hpn_buffer_size = 2 * 1024 * 1024;
+
 /* -- channel core */
 
 void
@@ -396,6 +400,7 @@ channel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,
 	c->local_window = window;
 	c->local_window_max = window;
 	c->local_maxpacket = maxpack;
+	c->dynamic_window = 0;
 	c->remote_name = xstrdup(remote_name);
 	c->ctl_chan = -1;
 	c->delayed = 1;		/* prevent call to channel_post handler */
@@ -1030,6 +1035,28 @@ channel_pre_connecting(struct ssh *ssh, Channel *c,
 	FD_SET(c->sock, writeset);
 }
 
+static int
+channel_tcpwinsz(void)
+{
+	u_int32_t tcpwinsz = 0;
+	socklen_t optsz = sizeof(tcpwinsz);
+	int ret = -1;
+
+	/* if we aren't on a socket return 128KB */
+	if (!packet_connection_is_on_socket())
+		return 128 * 1024;
+
+	ret = getsockopt(packet_get_connection_in(),
+			 SOL_SOCKET, SO_RCVBUF, &tcpwinsz, &optsz);
+	/* return no more than SSHBUF_SIZE_MAX (currently 256MB) */
+	if ((ret == 0) && tcpwinsz > SSHBUF_SIZE_MAX)
+		tcpwinsz = SSHBUF_SIZE_MAX;
+
+	debug2("tcpwinsz: tcp connection %d, Receive window: %d",
+	       packet_get_connection_in(), tcpwinsz);
+	return tcpwinsz;
+}
+
 static void
 channel_pre_open(struct ssh *ssh, Channel *c,
     fd_set *readset, fd_set *writeset)
@@ -2127,21 +2154,30 @@ channel_check_window(struct ssh *ssh, Channel *c)
 	    c->local_maxpacket*3) ||
 	    c->local_window < c->local_window_max/2) &&
 	    c->local_consumed > 0) {
+		u_int addition = 0;
+		u_int32_t tcpwinsz = channel_tcpwinsz();
+		/* adjust max window size if we are in a dynamic environment */
+		if (c->dynamic_window && (tcpwinsz > c->local_window_max)) {
+			/* grow the window somewhat aggressively to maintain pressure */
+			addition = 1.5 * (tcpwinsz - c->local_window_max);
+			c->local_window_max += addition;
+			debug("Channel: Window growth to %d by %d bytes", c->local_window_max, addition);
+		}
 		if (!c->have_remote_id)
 			fatal(":%s: channel %d: no remote id",
 			    __func__, c->self);
 		if ((r = sshpkt_start(ssh,
 		    SSH2_MSG_CHANNEL_WINDOW_ADJUST)) != 0 ||
 		    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||
-		    (r = sshpkt_put_u32(ssh, c->local_consumed)) != 0 ||
+		    (r = sshpkt_put_u32(ssh, c->local_consumed + addition)) != 0 ||
 		    (r = sshpkt_send(ssh)) != 0) {
 			fatal("%s: channel %i: %s", __func__,
 			    c->self, ssh_err(r));
 		}
 		debug2("channel %d: window %d sent adjust %d",
 		    c->self, c->local_window,
-		    c->local_consumed);
-		c->local_window += c->local_consumed;
+		    c->local_consumed + addition);
+		c->local_window += c->local_consumed + addition;
 		c->local_consumed = 0;
 	}
 	return 1;
@@ -2491,7 +2527,7 @@ channel_output_poll_input_open(struct ssh *ssh, Channel *c)
 	size_t len, plen;
 	const u_char *pkt;
 	int r;
-
+	
 	if ((len = sshbuf_len(c->input)) == 0) {
 		if (c->istate == CHAN_INPUT_WAIT_DRAIN) {
 			/*
@@ -2537,7 +2573,6 @@ channel_output_poll_input_open(struct ssh *ssh, Channel *c)
 			    c->self, ssh_err(r));
 		}
 		c->remote_window -= plen;
-		return;
 	}
 
 	/* Enqueue packet for buffered data. */
@@ -2609,7 +2644,7 @@ channel_output_poll(struct ssh *ssh)
 		c = sc->channels[i];
 		if (c == NULL)
 			continue;
-
+		
 		/*
 		 * We are only interested in channels that can have buffered
 		 * incoming data.
@@ -2619,10 +2654,10 @@ channel_output_poll(struct ssh *ssh)
 		if ((c->flags & (CHAN_CLOSE_SENT|CHAN_CLOSE_RCVD))) {
 			/* XXX is this true? */
 			debug3("channel %d: will not send data after close",
-			    c->self);
+			       c->self);
 			continue;
 		}
-
+		
 		/* Get the amount of buffered data for this channel. */
 		if (c->istate == CHAN_INPUT_OPEN ||
 		    c->istate == CHAN_INPUT_WAIT_DRAIN)
@@ -3311,6 +3346,15 @@ channel_fwd_bind_addr(const char *listen_addr, int *wildcardp,
 	return addr;
 }
 
+
+void
+channel_set_hpn(int external_hpn_disabled, int external_hpn_buffer_size)
+{
+	hpn_disabled = external_hpn_disabled;
+	hpn_buffer_size = external_hpn_buffer_size;
+	debug("HPN Disabled: %d, HPN Buffer Size: %d", hpn_disabled, hpn_buffer_size);
+}
+
 static int
 channel_setup_fwd_listener_tcpip(struct ssh *ssh, int type,
     struct Forward *fwd, int *allocated_listen_port,
@@ -3451,9 +3495,11 @@ channel_setup_fwd_listener_tcpip(struct ssh *ssh, int type,
 		}
 
 		/* Allocate a channel number for the socket. */
+		/* explicitly test for hpn disabled option. if true use smaller window size */
 		c = channel_new(ssh, "port listener", type, sock, sock, -1,
-		    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,
-		    0, "port listener", 1);
+				hpn_disabled ? CHAN_TCP_WINDOW_DEFAULT : hpn_buffer_size,
+				CHAN_TCP_PACKET_DEFAULT,
+				0, "port listener", 1);
 		c->path = xstrdup(host);
 		c->host_port = fwd->connect_port;
 		c->listening_addr = addr == NULL ? NULL : xstrdup(addr);
@@ -4590,8 +4636,9 @@ x11_create_display_inet(struct ssh *ssh, int x11_display_offset,
 		sock = socks[n];
 		nc = channel_new(ssh, "x11 listener",
 		    SSH_CHANNEL_X11_LISTENER, sock, sock, -1,
-		    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,
-		    0, "X11 inet listener", 1);
+				 hpn_disabled ? CHAN_X11_WINDOW_DEFAULT : hpn_buffer_size,
+				 CHAN_X11_PACKET_DEFAULT,
+				 0, "X11 inet listener", 1);
 		nc->single_connection = single_connection;
 		(*chanids)[n] = nc->self;
 	}
diff --git a/channels.h b/channels.h
index 1aeafe94..67594b58 100644
--- a/channels.h
+++ b/channels.h
@@ -150,6 +150,7 @@ struct Channel {
 	u_int	local_window_max;
 	u_int	local_consumed;
 	u_int	local_maxpacket;
+	int	dynamic_window;
 	int     extended_usage;
 	int	single_connection;
 
@@ -340,4 +341,7 @@ void	 chan_rcvd_ieof(struct ssh *, Channel *);
 void	 chan_write_failed(struct ssh *, Channel *);
 void	 chan_obuf_empty(struct ssh *, Channel *);
 
+/* hpn handler */
+void     channel_set_hpn(int, int);
+
 #endif
diff --git a/cipher-ctr-mt.c b/cipher-ctr-mt.c
new file mode 100644
index 00000000..a2982282
--- /dev/null
+++ b/cipher-ctr-mt.c
@@ -0,0 +1,678 @@
+/*
+ * OpenSSH Multi-threaded AES-CTR Cipher
+ *
+ * Author: Benjamin Bennett <ben@psc.edu>
+ * Author: Mike Tasota <tasota@gmail.com>
+ * Author: Chris Rapier <rapier@psc.edu>
+ * Copyright (c) 2008-2013 Pittsburgh Supercomputing Center. All rights reserved.
+ *
+ * Based on original OpenSSH AES-CTR cipher. Small portions remain unchanged,
+ * Copyright (c) 2003 Markus Friedl <markus@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include "includes.h"
+
+#if defined(WITH_OPENSSL)
+#include <sys/types.h>
+
+#include <stdarg.h>
+#include <string.h>
+
+#include <openssl/evp.h>
+
+#include "xmalloc.h"
+#include "log.h"
+#include <unistd.h>
+
+/* compatibility with old or broken OpenSSL versions */
+#include "openbsd-compat/openssl-compat.h"
+
+#ifndef USE_BUILTIN_RIJNDAEL
+#include <openssl/aes.h>
+#endif
+
+#include <pthread.h>
+
+/*-------------------- TUNABLES --------------------*/
+/* maximum number of threads and queues */
+#define MAX_THREADS      32 
+#define MAX_NUMKQ        (MAX_THREADS * 2)
+
+/* Number of pregen threads to use */
+int cipher_threads = 2;
+
+/* Number of keystream queues */
+int numkq = 4;
+
+/* Length of a keystream queue */
+#define KQLEN		4096
+
+/* Processor cacheline length */
+#define CACHELINE_LEN	64
+
+/* Collect thread stats and print at cancellation when in debug mode */
+#define CIPHER_THREAD_STATS
+
+/* Can the system do unaligned loads natively? */
+#if defined(__aarch64__) || \
+    defined(__i386__)    || \
+    defined(__powerpc__) || \
+    defined(__x86_64__)
+# define CIPHER_UNALIGNED_OK
+#endif
+#if defined(__SIZEOF_INT128__)
+# define CIPHER_INT128_OK
+#endif
+/*-------------------- END TUNABLES --------------------*/
+
+
+const EVP_CIPHER *evp_aes_ctr_mt(void);
+
+#ifdef CIPHER_THREAD_STATS
+/*
+ * Struct to collect thread stats
+ */
+struct thread_stats {
+	u_int	fills;
+	u_int	skips;
+	u_int	waits;
+	u_int	drains;
+};
+
+/*
+ * Debug print the thread stats
+ * Use with pthread_cleanup_push for displaying at thread cancellation
+ */
+static void
+thread_loop_stats(void *x)
+{
+	struct thread_stats *s = x;
+
+	debug("AES-CTR MT tid %lu - %u fills, %u skips, %u waits", pthread_self(),
+			s->fills, s->skips, s->waits);
+}
+
+# define STATS_STRUCT(s)	struct thread_stats s
+# define STATS_INIT(s)		{ memset(&s, 0, sizeof(s)); }
+# define STATS_FILL(s)		{ s.fills++; }
+# define STATS_SKIP(s)		{ s.skips++; }
+# define STATS_WAIT(s)		{ s.waits++; }
+# define STATS_DRAIN(s)		{ s.drains++; }
+#else
+# define STATS_STRUCT(s)
+# define STATS_INIT(s)
+# define STATS_FILL(s)
+# define STATS_SKIP(s)
+# define STATS_WAIT(s)
+# define STATS_DRAIN(s)
+#endif
+
+/* Keystream Queue state */
+enum {
+	KQINIT,
+	KQEMPTY,
+	KQFILLING,
+	KQFULL,
+	KQDRAINING
+};
+
+/* Keystream Queue struct */
+struct kq {
+	u_char		keys[KQLEN][AES_BLOCK_SIZE];
+	u_char		ctr[AES_BLOCK_SIZE];
+	u_char		pad0[CACHELINE_LEN];
+	int		qstate;
+	pthread_mutex_t	lock;
+	pthread_cond_t	cond;
+	u_char		pad1[CACHELINE_LEN];
+};
+
+/* Context struct */
+struct ssh_aes_ctr_ctx_mt
+{
+	int             struct_id;
+	struct kq	q[MAX_NUMKQ];
+	AES_KEY		aes_ctx;
+	STATS_STRUCT(stats);
+	u_char		aes_counter[AES_BLOCK_SIZE];
+	pthread_t	tid[MAX_THREADS];
+	int             id[MAX_THREADS];
+	pthread_rwlock_t tid_lock;
+#ifdef __APPLE__
+	pthread_rwlock_t stop_lock;
+	int		exit_flag;
+#endif /* __APPLE__ */
+	int		state;
+	int		qidx;
+	int		ridx;
+};
+
+/* <friedl>
+ * increment counter 'ctr',
+ * the counter is of size 'len' bytes and stored in network-byte-order.
+ * (LSB at ctr[len-1], MSB at ctr[0])
+ */
+static void
+ssh_ctr_inc(u_char *ctr, size_t len)
+{
+	int i;
+
+	for (i = len - 1; i >= 0; i--)
+		if (++ctr[i])	/* continue on overflow */
+			return;
+}
+
+/*
+ * Add num to counter 'ctr'
+ */
+static void
+ssh_ctr_add(u_char *ctr, uint32_t num, u_int len)
+{
+	int i;
+	uint16_t n;
+
+	for (n = 0, i = len - 1; i >= 0 && (num || n); i--) {
+		n = ctr[i] + (num & 0xff) + n;
+		num >>= 8;
+		ctr[i] = n & 0xff;
+		n >>= 8;
+	}
+}
+
+/*
+ * Threads may be cancelled in a pthread_cond_wait, we must free the mutex
+ */
+static void
+thread_loop_cleanup(void *x)
+{
+	pthread_mutex_unlock((pthread_mutex_t *)x);
+}
+
+#ifdef __APPLE__
+/* Check if we should exit, we are doing both cancel and exit condition
+ * since on OSX threads seem to occasionally fail to notice when they have
+ * been cancelled. We want to have a backup to make sure that we won't hang
+ * when the main process join()-s the cancelled thread.
+ */
+static void
+thread_loop_check_exit(struct ssh_aes_ctr_ctx_mt *c)
+{
+	int exit_flag;
+
+	pthread_rwlock_rdlock(&c->stop_lock);
+	exit_flag = c->exit_flag;
+	pthread_rwlock_unlock(&c->stop_lock);
+
+	if (exit_flag)
+		pthread_exit(NULL);
+}
+#else
+# define thread_loop_check_exit(s)
+#endif /* __APPLE__ */
+
+/*
+ * Helper function to terminate the helper threads
+ */
+static void
+stop_and_join_pregen_threads(struct ssh_aes_ctr_ctx_mt *c)
+{
+	int i;
+
+#ifdef __APPLE__
+	/* notify threads that they should exit */
+	pthread_rwlock_wrlock(&c->stop_lock);
+	c->exit_flag = TRUE;
+	pthread_rwlock_unlock(&c->stop_lock);
+#endif /* __APPLE__ */
+
+	/* Cancel pregen threads */
+	for (i = 0; i < cipher_threads; i++) {
+		debug ("Canceled %lu (%d,%d)", c->tid[i], c->struct_id, c->id[i]);
+		pthread_cancel(c->tid[i]);
+	}
+	for (i = 0; i < numkq; i++) {
+		pthread_mutex_lock(&c->q[i].lock);
+		pthread_cond_broadcast(&c->q[i].cond);
+		pthread_mutex_unlock(&c->q[i].lock);
+	}
+	for (i = 0; i < cipher_threads; i++) {
+		if (pthread_kill(c->tid[i], 0) != 0)
+			debug3("AES-CTR MT pthread_join failure: Invalid thread id %lu in %s", c->tid[i], __FUNCTION__);
+		else {
+			debug ("Joining %lu (%d, %d)", c->tid[i], c->struct_id, c->id[i]);
+			pthread_join(c->tid[i], NULL);
+		}
+	}
+}
+
+/*
+ * The life of a pregen thread:
+ *    Find empty keystream queues and fill them using their counter.
+ *    When done, update counter for the next fill.
+ */
+static void *
+thread_loop(void *x)
+{
+	AES_KEY key;
+	STATS_STRUCT(stats);
+	struct ssh_aes_ctr_ctx_mt *c = x;
+	struct kq *q;
+	int i;
+	int qidx;
+	pthread_t first_tid;
+
+	/* Threads stats on cancellation */
+	STATS_INIT(stats);
+#ifdef CIPHER_THREAD_STATS
+	pthread_cleanup_push(thread_loop_stats, &stats);
+#endif
+
+	/* Thread local copy of AES key */
+	memcpy(&key, &c->aes_ctx, sizeof(key));
+
+	pthread_rwlock_rdlock(&c->tid_lock);
+	first_tid = c->tid[0];
+	pthread_rwlock_unlock(&c->tid_lock);
+
+	/*
+	 * Handle the special case of startup, one thread must fill
+	 * the first KQ then mark it as draining. Lock held throughout.
+	 */
+	if (pthread_equal(pthread_self(), first_tid)) {
+		q = &c->q[0];
+		pthread_mutex_lock(&q->lock);
+		if (q->qstate == KQINIT) {
+			for (i = 0; i < KQLEN; i++) {
+				AES_encrypt(q->ctr, q->keys[i], &key);
+				ssh_ctr_inc(q->ctr, AES_BLOCK_SIZE);
+			}
+			ssh_ctr_add(q->ctr, KQLEN * (numkq - 1), AES_BLOCK_SIZE);
+			q->qstate = KQDRAINING;
+			STATS_FILL(stats);
+			pthread_cond_broadcast(&q->cond);
+		}
+		pthread_mutex_unlock(&q->lock);
+	} else
+		STATS_SKIP(stats);
+
+	/*
+	 * Normal case is to find empty queues and fill them, skipping over
+	 * queues already filled by other threads and stopping to wait for
+	 * a draining queue to become empty.
+	 *
+	 * Multiple threads may be waiting on a draining queue and awoken
+	 * when empty.  The first thread to wake will mark it as filling,
+	 * others will move on to fill, skip, or wait on the next queue.
+	 */
+	for (qidx = 1;; qidx = (qidx + 1) % numkq) {
+		/* Check if I was cancelled, also checked in cond_wait */
+		pthread_testcancel();
+
+		/* Check if we should exit as well */
+		thread_loop_check_exit(c);
+
+		/* Lock queue and block if its draining */
+		q = &c->q[qidx];
+		pthread_mutex_lock(&q->lock);
+		pthread_cleanup_push(thread_loop_cleanup, &q->lock);
+		while (q->qstate == KQDRAINING || q->qstate == KQINIT) {
+			STATS_WAIT(stats);
+			thread_loop_check_exit(c);
+			pthread_cond_wait(&q->cond, &q->lock);
+		}
+		pthread_cleanup_pop(0);
+
+		/* If filling or full, somebody else got it, skip */
+		if (q->qstate != KQEMPTY) {
+			pthread_mutex_unlock(&q->lock);
+			STATS_SKIP(stats);
+			continue;
+		}
+
+		/*
+		 * Empty, let's fill it.
+		 * Queue lock is relinquished while we do this so others
+		 * can see that it's being filled.
+		 */
+		q->qstate = KQFILLING;
+		pthread_cond_broadcast(&q->cond);
+		pthread_mutex_unlock(&q->lock);
+		for (i = 0; i < KQLEN; i++) {
+			AES_encrypt(q->ctr, q->keys[i], &key);
+			ssh_ctr_inc(q->ctr, AES_BLOCK_SIZE);
+		}
+
+		/* Re-lock, mark full and signal consumer */
+		pthread_mutex_lock(&q->lock);
+		ssh_ctr_add(q->ctr, KQLEN * (numkq - 1), AES_BLOCK_SIZE);
+		q->qstate = KQFULL;
+		STATS_FILL(stats);
+		pthread_cond_broadcast(&q->cond);
+		pthread_mutex_unlock(&q->lock);
+	}
+
+#ifdef CIPHER_THREAD_STATS
+	/* Stats */
+	pthread_cleanup_pop(1);
+#endif
+
+	return NULL;
+}
+
+static int
+ssh_aes_ctr(EVP_CIPHER_CTX *ctx, u_char *dest, const u_char *src,
+    LIBCRYPTO_EVP_INL_TYPE len)
+{
+	typedef union {
+#ifdef CIPHER_INT128_OK
+		__uint128_t *u128;
+#endif
+		uint64_t *u64;
+		uint32_t *u32;
+		uint8_t *u8;
+		const uint8_t *cu8;
+		uintptr_t u;
+	} ptrs_t;
+	ptrs_t destp, srcp, bufp;
+	uintptr_t align;
+	struct ssh_aes_ctr_ctx_mt *c;
+	struct kq *q, *oldq;
+	int ridx;
+	u_char *buf;
+
+	if (len == 0)
+		return 1;
+	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL)
+		return 0;
+
+	q = &c->q[c->qidx];
+	ridx = c->ridx;
+
+	/* src already padded to block multiple */
+	srcp.cu8 = src;
+	destp.u8 = dest;
+	while (len > 0) {
+		buf = q->keys[ridx];
+		bufp.u8 = buf;
+
+		/* figure out the alignment on the fly */
+#ifdef CIPHER_UNALIGNED_OK
+		align = 0;
+#else
+		align = destp.u | srcp.u | bufp.u;
+#endif
+
+#ifdef CIPHER_INT128_OK
+		if ((align & 0xf) == 0) {
+			destp.u128[0] = srcp.u128[0] ^ bufp.u128[0];
+		} else
+#endif
+		if ((align & 0x7) == 0) {
+			destp.u64[0] = srcp.u64[0] ^ bufp.u64[0];
+			destp.u64[1] = srcp.u64[1] ^ bufp.u64[1];
+		} else if ((align & 0x3) == 0) {
+			destp.u32[0] = srcp.u32[0] ^ bufp.u32[0];
+			destp.u32[1] = srcp.u32[1] ^ bufp.u32[1];
+			destp.u32[2] = srcp.u32[2] ^ bufp.u32[2];
+			destp.u32[3] = srcp.u32[3] ^ bufp.u32[3];
+		} else {
+			size_t i;
+			for (i = 0; i < AES_BLOCK_SIZE; ++i)
+				dest[i] = src[i] ^ buf[i];
+		}
+
+		destp.u += AES_BLOCK_SIZE;
+		srcp.u += AES_BLOCK_SIZE;
+		len -= AES_BLOCK_SIZE;
+		ssh_ctr_inc(c->aes_counter, AES_BLOCK_SIZE);
+
+		/* Increment read index, switch queues on rollover */
+		if ((ridx = (ridx + 1) % KQLEN) == 0) {
+			oldq = q;
+
+			/* Mark next queue draining, may need to wait */
+			c->qidx = (c->qidx + 1) % numkq;
+			q = &c->q[c->qidx];
+			pthread_mutex_lock(&q->lock);
+			while (q->qstate != KQFULL) {
+				STATS_WAIT(c->stats);
+				pthread_cond_wait(&q->cond, &q->lock);
+			}
+			q->qstate = KQDRAINING;
+			pthread_cond_broadcast(&q->cond);
+			pthread_mutex_unlock(&q->lock);
+
+			/* Mark consumed queue empty and signal producers */
+			pthread_mutex_lock(&oldq->lock);
+			oldq->qstate = KQEMPTY;
+			STATS_DRAIN(c->stats);
+			pthread_cond_broadcast(&oldq->cond);
+			pthread_mutex_unlock(&oldq->lock);
+		}
+	}
+	c->ridx = ridx;
+	return 1;
+}
+
+#define HAVE_NONE       0
+#define HAVE_KEY        1
+#define HAVE_IV         2
+
+int X = 0;
+
+static int
+ssh_aes_ctr_init(EVP_CIPHER_CTX *ctx, const u_char *key, const u_char *iv,
+    int enc)
+{
+	struct ssh_aes_ctr_ctx_mt *c;
+	int i;
+
+	/* get the number of cores in the system */
+	/* if it's not linux it currently defaults to 2 */
+	/* divide by 2 to get threads for each direction (MODE_IN||MODE_OUT) */
+#ifdef __linux__
+	cipher_threads = sysconf(_SC_NPROCESSORS_ONLN) / 2;
+#endif /*__linux__*/
+#ifdef __APPLE__
+	cipher_threads = sysconf(_SC_NPROCESSORS_ONLN) / 2;
+#endif /*__APPLE__*/
+#ifdef __FREEBSD__
+	int req[2];
+	size_t len;
+
+	req[0] = CTL_HW;
+	req[1] = HW_NCPU;
+
+	len = sizeof(ncpu);
+        sysctl(req, 2, &cipher_threads, &len, NULL, 0);
+	cipher_threads = cipher_threads / 2;
+#endif /*__FREEBSD__*/
+
+	/* if they have less than 4 cores spin up 4 threads anyway */
+	if (cipher_threads < 2) 
+		cipher_threads = 2;
+		
+	/* assure that we aren't trying to create more threads */
+	/* than we have in the struct. cipher_threads is half the */
+	/* total of allowable threads hence the odd looking math here */
+	if (cipher_threads * 2 > MAX_THREADS)
+		cipher_threads = MAX_THREADS / 2;
+
+	/* set the number of keystream queues */
+	numkq = cipher_threads * 2;
+
+	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
+		c = xmalloc(sizeof(*c));
+		pthread_rwlock_init(&c->tid_lock, NULL);
+#ifdef __APPLE__
+		pthread_rwlock_init(&c->stop_lock, NULL);
+		c->exit_flag = FALSE;
+#endif /* __APPLE__ */
+
+		c->state = HAVE_NONE;
+		for (i = 0; i < numkq; i++) {
+			pthread_mutex_init(&c->q[i].lock, NULL);
+			pthread_cond_init(&c->q[i].cond, NULL);
+		}
+
+		STATS_INIT(c->stats);
+		EVP_CIPHER_CTX_set_app_data(ctx, c);
+	}
+
+	if (c->state == (HAVE_KEY | HAVE_IV)) {
+		/* tell the pregen threads to exit */
+		stop_and_join_pregen_threads(c);
+		
+#ifdef __APPLE__
+		/* reset the exit flag */
+		c->exit_flag = FALSE;
+#endif /* __APPLE__ */
+
+		/* Start over getting key & iv */
+		c->state = HAVE_NONE;
+	}
+
+	if (key != NULL) {
+		AES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+		    &c->aes_ctx);
+		c->state |= HAVE_KEY;
+	}
+
+	if (iv != NULL) {
+		memcpy(c->aes_counter, iv, AES_BLOCK_SIZE);
+		c->state |= HAVE_IV;
+	}
+
+	if (c->state == (HAVE_KEY | HAVE_IV)) {
+		/* Clear queues */
+		memcpy(c->q[0].ctr, c->aes_counter, AES_BLOCK_SIZE);
+		c->q[0].qstate = KQINIT;
+		for (i = 1; i < numkq; i++) {
+			memcpy(c->q[i].ctr, c->aes_counter, AES_BLOCK_SIZE);
+			ssh_ctr_add(c->q[i].ctr, i * KQLEN, AES_BLOCK_SIZE);
+			c->q[i].qstate = KQEMPTY;
+		}
+		c->qidx = 0;
+		c->ridx = 0;
+
+		/* Start threads */
+		for (i = 0; i < cipher_threads; i++) {
+			pthread_rwlock_wrlock(&c->tid_lock);
+			if (pthread_create(&c->tid[i], NULL, thread_loop, c) != 0)
+				debug ("AES-CTR MT Could not create thread in %s", __FUNCTION__); /*should die here */
+			else {
+				if (!c->struct_id)
+					c->struct_id = X++;
+				c->id[i] = i;
+				debug ("AES-CTR MT spawned a thread with id %lu in %s (%d, %d)", c->tid[i], __FUNCTION__, c->struct_id, c->id[i]);
+			}
+			pthread_rwlock_unlock(&c->tid_lock);
+		}
+		pthread_mutex_lock(&c->q[0].lock);
+		while (c->q[0].qstate == KQINIT)
+			pthread_cond_wait(&c->q[0].cond, &c->q[0].lock);
+		pthread_mutex_unlock(&c->q[0].lock);
+	}
+	return 1;
+}
+
+/* this function is no longer used but might prove handy in the future
+ * this comment also applies to ssh_aes_ctr_thread_reconstruction
+ */
+void
+ssh_aes_ctr_thread_destroy(EVP_CIPHER_CTX *ctx)
+{
+	struct ssh_aes_ctr_ctx_mt *c;
+
+	c = EVP_CIPHER_CTX_get_app_data(ctx);
+	stop_and_join_pregen_threads(c);
+}
+
+void
+ssh_aes_ctr_thread_reconstruction(EVP_CIPHER_CTX *ctx)
+{
+	struct ssh_aes_ctr_ctx_mt *c;
+	int i;
+	c = EVP_CIPHER_CTX_get_app_data(ctx);
+	/* reconstruct threads */
+	for (i = 0; i < cipher_threads; i++) {
+		pthread_rwlock_wrlock(&c->tid_lock);
+		if (pthread_create(&c->tid[i], NULL, thread_loop, c) !=0 )
+			debug("AES-CTR MT could not create thread in %s", __FUNCTION__);
+		else {
+			c->struct_id = X++;
+			c->id[i] = i;
+			debug ("AES-CTR MT spawned a thread with id %lu in %s (%d, %d)", c->tid[i], __FUNCTION__, c->struct_id, c->id[i]);
+			debug("AES-CTR MT spawned a thread with id %lu in %s", c->tid[i], __FUNCTION__);
+		}
+		pthread_rwlock_unlock(&c->tid_lock);
+	}
+}
+
+static int
+ssh_aes_ctr_cleanup(EVP_CIPHER_CTX *ctx)
+{
+	struct ssh_aes_ctr_ctx_mt *c;
+
+	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) != NULL) {
+#ifdef CIPHER_THREAD_STATS
+		debug("AES-CTR MT main thread: %u drains, %u waits", c->stats.drains,
+		      c->stats.waits);
+#endif
+		stop_and_join_pregen_threads(c);
+
+		memset(c, 0, sizeof(*c));
+		free(c);
+		EVP_CIPHER_CTX_set_app_data(ctx, NULL);
+	}
+	return 1;
+}
+
+/* <friedl> */
+const EVP_CIPHER *
+evp_aes_ctr_mt(void)
+{
+# if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	static EVP_CIPHER *aes_ctr;
+	aes_ctr = EVP_CIPHER_meth_new(NID_undef, 16/*block*/, 16/*key*/);
+	EVP_CIPHER_meth_set_iv_length(aes_ctr, AES_BLOCK_SIZE);
+	EVP_CIPHER_meth_set_init(aes_ctr, ssh_aes_ctr_init);
+	EVP_CIPHER_meth_set_cleanup(aes_ctr, ssh_aes_ctr_cleanup);
+	EVP_CIPHER_meth_set_do_cipher(aes_ctr, ssh_aes_ctr);
+#  ifndef SSH_OLD_EVP
+	EVP_CIPHER_meth_set_flags(aes_ctr, EVP_CIPH_CBC_MODE
+				      | EVP_CIPH_VARIABLE_LENGTH
+				      | EVP_CIPH_ALWAYS_CALL_INIT
+				      | EVP_CIPH_CUSTOM_IV);
+#  endif /*SSH_OLD_EVP*/
+	return (aes_ctr);
+# else /*earlier version of openssl*/
+	static EVP_CIPHER aes_ctr;
+	memset(&aes_ctr, 0, sizeof(EVP_CIPHER));
+	aes_ctr.nid = NID_undef;
+	aes_ctr.block_size = AES_BLOCK_SIZE;
+	aes_ctr.iv_len = AES_BLOCK_SIZE;
+	aes_ctr.key_len = 16;
+	aes_ctr.init = ssh_aes_ctr_init;
+	aes_ctr.cleanup = ssh_aes_ctr_cleanup;
+	aes_ctr.do_cipher = ssh_aes_ctr;
+#  ifndef SSH_OLD_EVP
+        aes_ctr.flags = EVP_CIPH_CBC_MODE | EVP_CIPH_VARIABLE_LENGTH |
+		EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CUSTOM_IV;
+#  endif /*SSH_OLD_EVP*/
+        return &aes_ctr;
+# endif /*OPENSSH_VERSION_NUMBER*/
+}
+
+#endif /* defined(WITH_OPENSSL) */
diff --git a/cipher.c b/cipher.c
index a72682a8..9a8e3d1c 100644
--- a/cipher.c
+++ b/cipher.c
@@ -52,6 +52,9 @@
 #include "openbsd-compat/openssl-compat.h"
 
 
+/* for multi-threaded aes-ctr cipher */
+extern const EVP_CIPHER *evp_aes_ctr_mt(void);
+
 struct sshcipher_ctx {
 	int	plaintext;
 	int	encrypt;
@@ -80,7 +83,7 @@ struct sshcipher {
 #endif
 };
 
-static const struct sshcipher ciphers[] = {
+static struct sshcipher ciphers[] = {
 #ifdef WITH_OPENSSL
 #ifndef OPENSSL_NO_DES
 	{ "3des-cbc",		8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },
@@ -140,6 +143,29 @@ cipher_alg_list(char sep, int auth_only)
 	return ret;
 }
 
+/* used to get the cipher name so when force rekeying to handle the
+ * single to multithreaded ctr cipher swap we only rekey when appropriate
+ */
+const char *
+cipher_ctx_name(const struct sshcipher_ctx *cc)
+{
+	return cc->cipher->name;
+}
+
+/* in order to get around sandbox and forking issues with a threaded cipher
+ * we set the initial pre-auth aes-ctr cipher to the default OpenSSH cipher
+ * post auth we set them to the new evp as defined by cipher-ctr-mt
+ */
+#ifdef WITH_OPENSSL
+void
+cipher_reset_multithreaded(void)
+{
+	cipher_by_name("aes128-ctr")->evptype = evp_aes_ctr_mt;
+	cipher_by_name("aes192-ctr")->evptype = evp_aes_ctr_mt;
+	cipher_by_name("aes256-ctr")->evptype = evp_aes_ctr_mt;
+}
+#endif
+
 u_int
 cipher_blocksize(const struct sshcipher *c)
 {
@@ -189,10 +215,10 @@ cipher_ctx_is_plaintext(struct sshcipher_ctx *cc)
 	return cc->plaintext;
 }
 
-const struct sshcipher *
+struct sshcipher *
 cipher_by_name(const char *name)
 {
-	const struct sshcipher *c;
+	struct sshcipher *c;
 	for (c = ciphers; c->name != NULL; c++)
 		if (strcmp(c->name, name) == 0)
 			return c;
@@ -214,7 +240,8 @@ ciphers_valid(const char *names)
 	for ((p = strsep(&cp, CIPHER_SEP)); p && *p != '\0';
 	    (p = strsep(&cp, CIPHER_SEP))) {
 		c = cipher_by_name(p);
-		if (c == NULL || (c->flags & CFLAG_INTERNAL) != 0) {
+		  if (c == NULL || ((c->flags & CFLAG_INTERNAL) != 0 &&
+				    (c->flags & CFLAG_NONE) != 0)) {
 			free(cipher_list);
 			return 0;
 		}
@@ -299,7 +326,14 @@ cipher_init(struct sshcipher_ctx **ccp, const struct sshcipher *cipher,
 			goto out;
 		}
 	}
-	if (EVP_CipherInit(cc->evp, NULL, (u_char *)key, NULL, -1) == 0) {
+#if OPENSSH_VERSION_NUMBER <= 0x10100000UL
+	/* in OpenSSL 1.1.0, EVP_CipherInit clears all previous setups;
+	   use EVP_CipherInit_ex for augmenting */
+	if (EVP_CipherInit_ex(cc->evp, NULL, NULL, (u_char *)key, NULL, -1) == 0)
+#else
+	if (EVP_CipherInit(cc->evp, NULL, (u_char *)key, NULL, -1) == 0)
+#endif
+	{
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
@@ -485,8 +519,12 @@ cipher_get_keyiv(struct sshcipher_ctx *cc, u_char *iv, u_int len)
 		   len, iv))
 		       return SSH_ERR_LIBCRYPTO_ERROR;
 	} else
-		memcpy(iv, cc->evp->iv, len);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		memcpy(iv, EVP_CIPHER_CTX_iv(cc->evp), len);
+#else
+	        memcpy(iv, cc->evp->iv, len);
 #endif
+#endif /*WITH_OPENSSL*/
 	return 0;
 }
 
@@ -519,15 +557,24 @@ cipher_set_keyiv(struct sshcipher_ctx *cc, const u_char *iv)
 		    EVP_CTRL_GCM_SET_IV_FIXED, -1, (void *)iv))
 			return SSH_ERR_LIBCRYPTO_ERROR;
 	} else
-		memcpy(cc->evp->iv, iv, evplen);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000
+		memcpy(EVP_CIPHER_CTX_iv(cc->evp), iv, evplen);
+#else
+	        memcpy(cc->evp->iv, iv, evplen);
 #endif
+#endif /*WITH_OPENSSL*/
 	return 0;
 }
 
 #ifdef WITH_OPENSSL
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+#define EVP_X_STATE(evp)	EVP_CIPHER_CTX_get_cipher_data(evp)
+#define EVP_X_STATE_LEN(evp)	EVP_CIPHER_impl_ctx_size(EVP_CIPHER_CTX_cipher(evp))
+#else
 #define EVP_X_STATE(evp)	(evp)->cipher_data
 #define EVP_X_STATE_LEN(evp)	(evp)->cipher->ctx_size
-#endif
+#endif /* OPENSSL_VERSION_NUMBER */
+#endif /* WITH_OPENSSL */
 
 int
 cipher_get_keycontext(const struct sshcipher_ctx *cc, u_char *dat)
diff --git a/cipher.h b/cipher.h
index dc7ecf11..7cba847e 100644
--- a/cipher.h
+++ b/cipher.h
@@ -48,7 +48,9 @@
 struct sshcipher;
 struct sshcipher_ctx;
 
-const struct sshcipher *cipher_by_name(const char *);
+void ssh_aes_ctr_thread_destroy(EVP_CIPHER_CTX *ctx); // defined in cipher-ctr-mt.c
+void ssh_aes_ctr_thread_reconstruction(EVP_CIPHER_CTX *ctx);
+struct sshcipher *cipher_by_name(const char *);
 const char *cipher_warning_message(const struct sshcipher_ctx *);
 int	 ciphers_valid(const char *);
 char	*cipher_alg_list(char, int);
@@ -65,6 +67,8 @@ u_int	 cipher_seclen(const struct sshcipher *);
 u_int	 cipher_authlen(const struct sshcipher *);
 u_int	 cipher_ivlen(const struct sshcipher *);
 u_int	 cipher_is_cbc(const struct sshcipher *);
+void	 cipher_reset_multithreaded(void);
+const char *cipher_ctx_name(const struct sshcipher_ctx *);
 
 u_int	 cipher_ctx_is_plaintext(struct sshcipher_ctx *);
 
diff --git a/clientloop.c b/clientloop.c
index ad35cb7b..a0f7af3e 100644
--- a/clientloop.c
+++ b/clientloop.c
@@ -1572,9 +1572,11 @@ client_request_x11(struct ssh *ssh, const char *request_type, int rchan)
 	sock = x11_connect_display(ssh);
 	if (sock < 0)
 		return NULL;
-	c = channel_new(ssh, "x11",
-	    SSH_CHANNEL_X11_OPEN, sock, sock, -1,
-	    CHAN_TCP_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT, 0, "x11", 1);
+        c = channel_new(ssh, "x11",
+			SSH_CHANNEL_X11_OPEN, sock, sock, -1,
+			/* again is this really necessary for X11? */
+			options.hpn_disabled ? CHAN_TCP_WINDOW_DEFAULT : options.hpn_buffer_size,
+			CHAN_X11_PACKET_DEFAULT, 0, "x11", 1);
 	c->force_drain = 1;
 	return c;
 }
@@ -1598,9 +1600,10 @@ client_request_agent(struct ssh *ssh, const char *request_type, int rchan)
 		return NULL;
 	}
 	c = channel_new(ssh, "authentication agent connection",
-	    SSH_CHANNEL_OPEN, sock, sock, -1,
-	    CHAN_X11_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0,
-	    "authentication agent connection", 1);
+			SSH_CHANNEL_OPEN, sock, sock, -1,
+			options.hpn_disabled ? CHAN_X11_WINDOW_DEFAULT : options.hpn_buffer_size,
+			CHAN_TCP_PACKET_DEFAULT, 0,
+			"authentication agent connection", 1);
 	c->force_drain = 1;
 	return c;
 }
@@ -1625,10 +1628,13 @@ client_request_tun_fwd(struct ssh *ssh, int tun_mode,
 	}
 	debug("Tunnel forwarding using interface %s", ifname);
 
-	c = channel_new(ssh, "tun", SSH_CHANNEL_OPENING, fd, fd, -1,
-	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, "tun", 1);
+        c = channel_new(ssh, "tun", SSH_CHANNEL_OPENING, fd, fd, -1,
+	    options.hpn_disabled ? CHAN_TCP_WINDOW_DEFAULT : options.hpn_buffer_size,
+	    CHAN_TCP_PACKET_DEFAULT, 0, "tun", 1);
 	c->datagram = 1;
 
+
+
 #if defined(SSH_TUN_FILTER)
 	if (options.tun_open == SSH_TUNMODE_POINTOPOINT)
 		channel_register_filter(ssh, c->self, sys_tun_infilter,
diff --git a/compat.c b/compat.c
index 0624dc6d..c4aee493 100644
--- a/compat.c
+++ b/compat.c
@@ -150,6 +150,13 @@ compat_datafellows(const char *version)
 			debug("match: %s pat %s compat 0x%08x",
 			    version, check[i].pat, check[i].bugs);
 			datafellows = check[i].bugs;	/* XXX for now */
+			/* Check to see if the remote side is OpenSSH and not HPN */
+			if (strstr(version, "OpenSSH") != NULL) {
+				if (strstr(version, "hpn") == NULL) {
+					datafellows |= SSH_BUG_LARGEWINDOW;
+					debug("Remote is NON-HPN aware");
+				}
+			}
 			return check[i].bugs;
 		}
 	}
diff --git a/compat.h b/compat.h
index d611d33e..2c5b2f9e 100644
--- a/compat.h
+++ b/compat.h
@@ -62,6 +62,7 @@
 #define SSH_BUG_CURVE25519PAD	0x10000000
 #define SSH_BUG_HOSTKEYS	0x20000000
 #define SSH_BUG_DHGEX_LARGE	0x40000000
+#define SSH_BUG_LARGEWINDOW	0x80000000
 
 u_int    compat_datafellows(const char *);
 int	 proto_spec(const char *);
diff --git a/configure.ac b/configure.ac
index 83e53075..c4bd8b4f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2603,9 +2603,6 @@ if test "x$openssl" = "xyes" ; then
 			                ;;
 				100*)   ;; # 1.0.x
 				200*)   ;; # LibreSSL
-			        *)
-					AC_MSG_ERROR([OpenSSL >= 1.1.0 is not yet supported (have "$ssl_library_ver")])
-			                ;;
 			esac
 			AC_MSG_RESULT([$ssl_library_ver])
 		],
diff --git a/dh.c b/dh.c
index ac8d5a0a..157cfd7b 100644
--- a/dh.c
+++ b/dh.c
@@ -216,14 +216,20 @@ choose_dh(int min, int wantbits, int max)
 /* diffie-hellman-groupN-sha1 */
 
 int
+#if OPENSSL_VERSION_NUMBER <= 0x10100000UL
+dh_pub_is_valid(const DH *dh, const BIGNUM *dh_pub)
+#else
 dh_pub_is_valid(DH *dh, BIGNUM *dh_pub)
+#endif
 {
 	int i;
 	int n = BN_num_bits(dh_pub);
 	int bits_set = 0;
 	BIGNUM *tmp;
-
-	if (dh_pub->neg) {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	const BIGNUM *p;
+#endif
+	if (BN_is_negative(dh_pub)) {
 		logit("invalid public DH value: negative");
 		return 0;
 	}
@@ -236,7 +242,9 @@ dh_pub_is_valid(DH *dh, BIGNUM *dh_pub)
 		error("%s: BN_new failed", __func__);
 		return 0;
 	}
-	if (!BN_sub(tmp, dh->p, BN_value_one()) ||
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	DH_get0_pqg(dh, &p, NULL, NULL);
+	if (!BN_sub(tmp, p, BN_value_one()) ||
 	    BN_cmp(dh_pub, tmp) != -1) {		/* pub_exp > p-2 */
 		BN_clear_free(tmp);
 		logit("invalid public DH value: >= p-1");
@@ -247,16 +255,40 @@ dh_pub_is_valid(DH *dh, BIGNUM *dh_pub)
 	for (i = 0; i <= n; i++)
 		if (BN_is_bit_set(dh_pub, i))
 			bits_set++;
-	debug2("bits set: %d/%d", bits_set, BN_num_bits(dh->p));
+
+	debug2("bits set: %d/%d", bits_set, BN_num_bits(p));
 
 	/*
 	 * if g==2 and bits_set==1 then computing log_g(dh_pub) is trivial
 	 */
 	if (bits_set < 4) {
 		logit("invalid public DH value (%d/%d)",
-		   bits_set, BN_num_bits(dh->p));
-		return 0;
+		      bits_set, BN_num_bits(p));
+	  return 0;
+	}
+#else
+	if (!BN_sub(tmp, dh->p, BN_value_one()) ||
+	    BN_cmp(dh_pub, tmp) != -1) {                /* pub_exp > p-2 */
+	  BN_clear_free(tmp);
+	  logit("invalid public DH value: >= p-1");
+	  return 0;
+	}
+	BN_clear_free(tmp);
+
+	for (i = 0; i <= n; i++)
+	  if (BN_is_bit_set(dh_pub, i))
+	    bits_set++;
+	debug2("bits set: %d/%d", bits_set, BN_num_bits(dh->p));
+
+	/*
+         * if g==2 and bits_set==1 then computing log_g(dh_pub) is trivial
+         */
+	if (bits_set < 4) {
+	  logit("invalid public DH value (%d/%d)",
+		bits_set, BN_num_bits(dh->p));
+	  return 0;
 	}
+#endif
 	return 1;
 }
 
@@ -264,10 +296,19 @@ int
 dh_gen_key(DH *dh, int need)
 {
 	int pbits;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	const BIGNUM *p, *pub_key;
+	BIGNUM *priv_key;
 
+	DH_get0_pqg(dh, &p, NULL, NULL);
+	if (need < 0 || p == NULL ||
+	    (pbits = BN_num_bits(p)) <= 0 ||
+	    need > INT_MAX / 2 || 2 * need > pbits)
+#else
 	if (need < 0 || dh->p == NULL ||
 	    (pbits = BN_num_bits(dh->p)) <= 0 ||
 	    need > INT_MAX / 2 || 2 * need > pbits)
+#endif
 		return SSH_ERR_INVALID_ARGUMENT;
 	if (need < 256)
 		need = 256;
@@ -275,6 +316,17 @@ dh_gen_key(DH *dh, int need)
 	 * Pollard Rho, Big step/Little Step attacks are O(sqrt(n)),
 	 * so double requested need here.
 	 */
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	DH_set_length(dh, MIN(need * 2, pbits - 1));
+	if (DH_generate_key(dh) == 0) {
+		return SSH_ERR_LIBCRYPTO_ERROR;
+	}
+	DH_get0_key(dh, &pub_key, &priv_key);
+	if (!dh_pub_is_valid(dh, pub_key)) {
+		BN_clear(priv_key);
+		return SSH_ERR_LIBCRYPTO_ERROR;
+	}
+#else
 	dh->length = MINIMUM(need * 2, pbits - 1);
 	if (DH_generate_key(dh) == 0 ||
 	    !dh_pub_is_valid(dh, dh->pub_key)) {
@@ -282,15 +334,38 @@ dh_gen_key(DH *dh, int need)
 		dh->priv_key = NULL;
 		return SSH_ERR_LIBCRYPTO_ERROR;
 	}
+#endif
 	return 0;
 }
 
 DH *
 dh_new_group_asc(const char *gen, const char *modulus)
 {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	DH *dh = NULL;
+	BIGNUM *p=NULL, *g=NULL;
+
+	if ((dh = DH_new()) == NULL ||
+	    (p = BN_new()) == NULL ||
+	    (g = BN_new()) == NULL)
+		goto null;
+	if (BN_hex2bn(&p, modulus) == 0 ||
+	    BN_hex2bn(&g, gen) == 0) {
+		goto null;
+	}
+	if (DH_set0_pqg(dh, p, NULL, g) == 0) {
+		goto null;
+	}
+	p = g = NULL;
+	return (dh);
+null:
+	BN_free(p);
+	BN_free(g);
+	DH_free(dh);
+	return NULL;
+#else
 	DH *dh;
-
-	if ((dh = DH_new()) == NULL)
+        if ((dh = DH_new()) == NULL)
 		return NULL;
 	if (BN_hex2bn(&dh->p, modulus) == 0 ||
 	    BN_hex2bn(&dh->g, gen) == 0) {
@@ -298,6 +373,7 @@ dh_new_group_asc(const char *gen, const char *modulus)
 		return NULL;
 	}
 	return (dh);
+#endif
 }
 
 /*
@@ -312,8 +388,13 @@ dh_new_group(BIGNUM *gen, BIGNUM *modulus)
 
 	if ((dh = DH_new()) == NULL)
 		return NULL;
-	dh->p = modulus;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	if (DH_set0_pqg(dh, modulus, NULL, gen) == 0)
+		return NULL;
+#else
+        dh->p = modulus;
 	dh->g = gen;
+#endif
 
 	return (dh);
 }
diff --git a/dh.h b/dh.h
index bcd485cf..8f0511c7 100644
--- a/dh.h
+++ b/dh.h
@@ -42,7 +42,11 @@ DH	*dh_new_group18(void);
 DH	*dh_new_group_fallback(int);
 
 int	 dh_gen_key(DH *, int);
+#if OPENSSL_VERSION_NUMBER <= 0x10100000UL
+int	 dh_pub_is_valid(const DH *, const BIGNUM *);
+#else
 int	 dh_pub_is_valid(DH *, BIGNUM *);
+#endif
 
 u_int	 dh_estimate(int);
 
diff --git a/digest-openssl.c b/digest-openssl.c
index 27709992..d210c013 100644
--- a/digest-openssl.c
+++ b/digest-openssl.c
@@ -43,7 +43,11 @@
 
 struct ssh_digest_ctx {
 	int alg;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	EVP_MD_CTX *mdctx;
+#else
 	EVP_MD_CTX mdctx;
+#endif
 };
 
 struct ssh_digest {
@@ -106,23 +110,39 @@ ssh_digest_bytes(int alg)
 size_t
 ssh_digest_blocksize(struct ssh_digest_ctx *ctx)
 {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	return EVP_MD_CTX_block_size(ctx->mdctx);
+#else
 	return EVP_MD_CTX_block_size(&ctx->mdctx);
+#endif
 }
 
 struct ssh_digest_ctx *
 ssh_digest_start(int alg)
 {
 	const struct ssh_digest *digest = ssh_digest_by_alg(alg);
+#if OPENSSL_VERSION_NUMBER <= 0x10100000UL
+	struct ssh_digest_ctx *ret = NULL;
+#else
 	struct ssh_digest_ctx *ret;
-
+#endif
 	if (digest == NULL || ((ret = calloc(1, sizeof(*ret))) == NULL))
 		return NULL;
 	ret->alg = alg;
-	EVP_MD_CTX_init(&ret->mdctx);
-	if (EVP_DigestInit_ex(&ret->mdctx, digest->mdfunc(), NULL) != 1) {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	if ((ret->mdctx = EVP_MD_CTX_new()) == NULL ||
+	    EVP_DigestInit_ex(ret->mdctx, digest->mdfunc(), NULL) != 1) {
+		EVP_MD_CTX_free(ret->mdctx);
 		free(ret);
 		return NULL;
 	}
+#else
+	EVP_MD_CTX_init(&ret->mdctx);
+	if (EVP_DigestInit_ex(&ret->mdctx, digest->mdfunc(), NULL) != 1) {
+	  free(ret);
+	  return NULL;
+	}
+#endif
 	return ret;
 }
 
@@ -132,7 +152,11 @@ ssh_digest_copy_state(struct ssh_digest_ctx *from, struct ssh_digest_ctx *to)
 	if (from->alg != to->alg)
 		return SSH_ERR_INVALID_ARGUMENT;
 	/* we have bcopy-style order while openssl has memcpy-style */
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	if (!EVP_MD_CTX_copy_ex(to->mdctx, from->mdctx))
+#else
 	if (!EVP_MD_CTX_copy_ex(&to->mdctx, &from->mdctx))
+#endif
 		return SSH_ERR_LIBCRYPTO_ERROR;
 	return 0;
 }
@@ -140,7 +164,11 @@ ssh_digest_copy_state(struct ssh_digest_ctx *from, struct ssh_digest_ctx *to)
 int
 ssh_digest_update(struct ssh_digest_ctx *ctx, const void *m, size_t mlen)
 {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	if (EVP_DigestUpdate(ctx->mdctx, m, mlen) != 1)
+#else
 	if (EVP_DigestUpdate(&ctx->mdctx, m, mlen) != 1)
+#endif
 		return SSH_ERR_LIBCRYPTO_ERROR;
 	return 0;
 }
@@ -161,7 +189,11 @@ ssh_digest_final(struct ssh_digest_ctx *ctx, u_char *d, size_t dlen)
 		return SSH_ERR_INVALID_ARGUMENT;
 	if (dlen < digest->digest_len) /* No truncation allowed */
 		return SSH_ERR_INVALID_ARGUMENT;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	if (EVP_DigestFinal_ex(ctx->mdctx, d, &l) != 1)
+#else
 	if (EVP_DigestFinal_ex(&ctx->mdctx, d, &l) != 1)
+#endif
 		return SSH_ERR_LIBCRYPTO_ERROR;
 	if (l != digest->digest_len) /* sanity */
 		return SSH_ERR_INTERNAL_ERROR;
@@ -172,7 +204,11 @@ void
 ssh_digest_free(struct ssh_digest_ctx *ctx)
 {
 	if (ctx != NULL) {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		EVP_MD_CTX_free(ctx->mdctx);
+#else
 		EVP_MD_CTX_cleanup(&ctx->mdctx);
+#endif
 		explicit_bzero(ctx, sizeof(*ctx));
 		free(ctx);
 	}
diff --git a/kex.c b/kex.c
index 25f9f66f..d6f3a713 100644
--- a/kex.c
+++ b/kex.c
@@ -52,6 +52,7 @@
 
 #include "ssherr.h"
 #include "sshbuf.h"
+#include "canohost.h"
 #include "digest.h"
 
 /* prototype */
@@ -822,6 +823,11 @@ kex_choose_conf(struct ssh *ssh)
 	int nenc, nmac, ncomp;
 	u_int mode, ctos, need, dh_need, authlen;
 	int r, first_kex_follows;
+	int auth_flag;
+	int log_flag = 0;
+	
+	auth_flag = packet_authentication_state(ssh);
+	debug("AUTH STATE IS %d", auth_flag);
 
 	debug2("local %s KEXINIT proposal", kex->server ? "server" : "client");
 	if ((r = kex_buf2prop(kex->my, NULL, &my)) != 0)
@@ -892,11 +898,35 @@ kex_choose_conf(struct ssh *ssh)
 			peer[ncomp] = NULL;
 			goto out;
 		}
+		debug("REQUESTED ENC.NAME is '%s'", newkeys->enc.name);
+		if (strcmp(newkeys->enc.name, "none") == 0) {
+			debug("Requesting NONE. Authflag is %d", auth_flag);
+			if (auth_flag == 1)
+				debug("None requested post authentication.");
+			else
+				fatal("Pre-authentication none cipher requests are not allowed.");
+		}
 		debug("kex: %s cipher: %s MAC: %s compression: %s",
 		    ctos ? "client->server" : "server->client",
 		    newkeys->enc.name,
 		    authlen == 0 ? newkeys->mac.name : "<implicit>",
 		    newkeys->comp.name);
+		/*
+		 * client starts with ctos = 0 && log flag = 0 and no log.
+		 * 2nd client pass ctos = 1 and flag = 1 so no log.
+		 * server starts with ctos = 1 && log_flag = 0 so log.
+		 * 2nd sever pass ctos = 1 && log flag = 1 so no log.
+		 * -cjr
+		 */
+		if (ctos && !log_flag) {
+			logit("SSH: Server;Ltype: Kex;Remote: %s-%d;Enc: %s;MAC: %s;Comp: %s",
+			    ssh_remote_ipaddr(ssh),
+			    ssh_remote_port(ssh),
+			    newkeys->enc.name,
+			    authlen == 0 ? newkeys->mac.name : "<implicit>",
+			    newkeys->comp.name);
+		}
+		log_flag = 1;
 	}
 	need = dh_need = 0;
 	for (mode = 0; mode < MODE_MAX; mode++) {
diff --git a/kexdhc.c b/kexdhc.c
index 9a9f1ea7..f4f08296 100644
--- a/kexdhc.c
+++ b/kexdhc.c
@@ -81,11 +81,24 @@ kexdh_client(struct ssh *ssh)
 		goto out;
 	}
 	debug("sending SSH2_MSG_KEXDH_INIT");
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+	const BIGNUM *pub_key;
+	if ((r = dh_gen_key(kex->dh, kex->we_need * 8)) != 0)
+		goto out;
+	DH_get0_key(kex->dh, &pub_key, NULL);
+	if ((r = sshpkt_start(ssh, SSH2_MSG_KEXDH_INIT)) != 0 ||
+	    (r = sshpkt_put_bignum2(ssh, pub_key)) != 0 ||
+	    (r = sshpkt_send(ssh)) != 0)
+		goto out;
+	}
+#else
 	if ((r = dh_gen_key(kex->dh, kex->we_need * 8)) != 0 ||
 	    (r = sshpkt_start(ssh, SSH2_MSG_KEXDH_INIT)) != 0 ||
 	    (r = sshpkt_put_bignum2(ssh, kex->dh->pub_key)) != 0 ||
 	    (r = sshpkt_send(ssh)) != 0)
-		goto out;
+	  goto out;
+#endif
 #ifdef DEBUG_KEXDH
 	DHparams_print_fp(stderr, kex->dh);
 	fprintf(stderr, "pub= ");
@@ -169,6 +182,11 @@ input_kex_dh(int type, u_int32_t seq, struct ssh *ssh)
 
 	/* calc and verify H */
 	hashlen = sizeof(hash);
+	{
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	const BIGNUM *pub_key;
+	DH_get0_key(kex->dh, &pub_key, NULL);
+#endif
 	if ((r = kex_dh_hash(
 	    kex->hash_alg,
 	    kex->client_version_string,
@@ -176,11 +194,16 @@ input_kex_dh(int type, u_int32_t seq, struct ssh *ssh)
 	    sshbuf_ptr(kex->my), sshbuf_len(kex->my),
 	    sshbuf_ptr(kex->peer), sshbuf_len(kex->peer),
 	    server_host_key_blob, sbloblen,
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	    pub_key,
+#else
 	    kex->dh->pub_key,
+#endif
 	    dh_server_pub,
 	    shared_secret,
 	    hash, &hashlen)) != 0)
 		goto out;
+	}
 
 	if ((r = sshkey_verify(server_host_key, signature, slen, hash, hashlen,
 	    kex->hostkey_alg, ssh->compat)) != 0)
diff --git a/kexdhs.c b/kexdhs.c
index 5dfca0a2..02afcd3d 100644
--- a/kexdhs.c
+++ b/kexdhs.c
@@ -101,6 +101,9 @@ input_kex_dh_init(int type, u_int32_t seq, struct ssh *ssh)
 	size_t sbloblen, slen;
 	size_t klen = 0, hashlen;
 	int kout, r;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	const BIGNUM *pub_key;
+#endif
 
 	if (kex->load_host_public_key == NULL ||
 	    kex->load_host_private_key == NULL) {
@@ -163,6 +166,9 @@ input_kex_dh_init(int type, u_int32_t seq, struct ssh *ssh)
 		goto out;
 	/* calc H */
 	hashlen = sizeof(hash);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	DH_get0_key(kex->dh, &pub_key, NULL);
+#endif
 	if ((r = kex_dh_hash(
 	    kex->hash_alg,
 	    kex->client_version_string,
@@ -171,7 +177,11 @@ input_kex_dh_init(int type, u_int32_t seq, struct ssh *ssh)
 	    sshbuf_ptr(kex->my), sshbuf_len(kex->my),
 	    server_host_key_blob, sbloblen,
 	    dh_client_pub,
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	    pub_key,
+#else
 	    kex->dh->pub_key,
+#endif
 	    shared_secret,
 	    hash, &hashlen)) != 0)
 		goto out;
@@ -195,9 +205,16 @@ input_kex_dh_init(int type, u_int32_t seq, struct ssh *ssh)
 	/* destroy_sensitive_data(); */
 
 	/* send server hostkey, DH pubkey 'f' and signed H */
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	DH_get0_key(kex->dh, &pub_key, NULL);
+#endif
 	if ((r = sshpkt_start(ssh, SSH2_MSG_KEXDH_REPLY)) != 0 ||
 	    (r = sshpkt_put_string(ssh, server_host_key_blob, sbloblen)) != 0 ||
-	    (r = sshpkt_put_bignum2(ssh, kex->dh->pub_key)) != 0 ||	/* f */
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	    (r = sshpkt_put_bignum2(ssh, pub_key)) != 0 ||	/* f */
+#else
+	    (r = sshpkt_put_bignum2(ssh, kex->dh->pub_key)) != 0 ||     /* f */
+#endif
 	    (r = sshpkt_put_string(ssh, signature, slen)) != 0 ||
 	    (r = sshpkt_send(ssh)) != 0)
 		goto out;
diff --git a/kexgexc.c b/kexgexc.c
index 762a9a32..f0da477a 100644
--- a/kexgexc.c
+++ b/kexgexc.c
@@ -118,11 +118,24 @@ input_kex_dh_gex_group(int type, u_int32_t seq, struct ssh *ssh)
 	p = g = NULL; /* belong to kex->dh now */
 
 	/* generate and send 'e', client DH public key */
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+	const BIGNUM *pub_key;
+	if ((r = dh_gen_key(kex->dh, kex->we_need * 8)) != 0)
+		goto out;
+	DH_get0_key(kex->dh, &pub_key, NULL);
+	if ((r = sshpkt_start(ssh, SSH2_MSG_KEX_DH_GEX_INIT)) != 0 ||
+	    (r = sshpkt_put_bignum2(ssh, pub_key)) != 0 ||
+	    (r = sshpkt_send(ssh)) != 0)
+		goto out;
+	}
+#else
 	if ((r = dh_gen_key(kex->dh, kex->we_need * 8)) != 0 ||
 	    (r = sshpkt_start(ssh, SSH2_MSG_KEX_DH_GEX_INIT)) != 0 ||
 	    (r = sshpkt_put_bignum2(ssh, kex->dh->pub_key)) != 0 ||
 	    (r = sshpkt_send(ssh)) != 0)
-		goto out;
+	  goto out;
+#endif
 	debug("SSH2_MSG_KEX_DH_GEX_INIT sent");
 #ifdef DEBUG_KEXDH
 	DHparams_print_fp(stderr, kex->dh);
@@ -212,6 +225,27 @@ input_kex_dh_gex_reply(int type, u_int32_t seq, struct ssh *ssh)
 
 	/* calc and verify H */
 	hashlen = sizeof(hash);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+	const BIGNUM *p, *g, *pub_key;
+	DH_get0_pqg(kex->dh, &p, NULL, &g);
+	DH_get0_key(kex->dh, &pub_key, NULL);
+	if ((r = kexgex_hash(
+	    kex->hash_alg,
+	    kex->client_version_string,
+	    kex->server_version_string,
+	    sshbuf_ptr(kex->my), sshbuf_len(kex->my),
+	    sshbuf_ptr(kex->peer), sshbuf_len(kex->peer),
+	    server_host_key_blob, sbloblen,
+	    kex->min, kex->nbits, kex->max,
+	    p, g,
+	    pub_key,
+	    dh_server_pub,
+	    shared_secret,
+	    hash, &hashlen)) != 0)
+		goto out;
+	}
+#else
 	if ((r = kexgex_hash(
 	    kex->hash_alg,
 	    kex->client_version_string,
@@ -225,7 +259,8 @@ input_kex_dh_gex_reply(int type, u_int32_t seq, struct ssh *ssh)
 	    dh_server_pub,
 	    shared_secret,
 	    hash, &hashlen)) != 0)
-		goto out;
+	        goto out;
+#endif
 
 	if ((r = sshkey_verify(server_host_key, signature, slen, hash,
 	    hashlen, kex->hostkey_alg, ssh->compat)) != 0)
diff --git a/kexgexs.c b/kexgexs.c
index f6983fd6..8c774adb 100644
--- a/kexgexs.c
+++ b/kexgexs.c
@@ -101,11 +101,23 @@ input_kex_dh_gex_request(int type, u_int32_t seq, struct ssh *ssh)
 		goto out;
 	}
 	debug("SSH2_MSG_KEX_DH_GEX_GROUP sent");
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+	const BIGNUM *p, *g;
+	DH_get0_pqg(kex->dh, &p, NULL, &g);
+	if ((r = sshpkt_start(ssh, SSH2_MSG_KEX_DH_GEX_GROUP)) != 0 ||
+	    (r = sshpkt_put_bignum2(ssh, p)) != 0 ||
+	    (r = sshpkt_put_bignum2(ssh, g)) != 0 ||
+	    (r = sshpkt_send(ssh)) != 0)
+		goto out;
+	}
+#else
 	if ((r = sshpkt_start(ssh, SSH2_MSG_KEX_DH_GEX_GROUP)) != 0 ||
 	    (r = sshpkt_put_bignum2(ssh, kex->dh->p)) != 0 ||
 	    (r = sshpkt_put_bignum2(ssh, kex->dh->g)) != 0 ||
 	    (r = sshpkt_send(ssh)) != 0)
-		goto out;
+	  goto out;
+#endif
 
 	/* Compute our exchange value in parallel with the client */
 	if ((r = dh_gen_key(kex->dh, kex->we_need * 8)) != 0)
@@ -191,6 +203,27 @@ input_kex_dh_gex_init(int type, u_int32_t seq, struct ssh *ssh)
 		goto out;
 	/* calc H */
 	hashlen = sizeof(hash);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+	const BIGNUM *p, *g, *pub_key;
+	DH_get0_pqg(kex->dh, &p, NULL, &g);
+	DH_get0_key(kex->dh, &pub_key, NULL);
+	if ((r = kexgex_hash(
+	    kex->hash_alg,
+	    kex->client_version_string,
+	    kex->server_version_string,
+	    sshbuf_ptr(kex->peer), sshbuf_len(kex->peer),
+	    sshbuf_ptr(kex->my), sshbuf_len(kex->my),
+	    server_host_key_blob, sbloblen,
+	    kex->min, kex->nbits, kex->max,
+	    p, g,
+	    dh_client_pub,
+	    pub_key,
+	    shared_secret,
+	    hash, &hashlen)) != 0)
+		goto out;
+	}
+#else
 	if ((r = kexgex_hash(
 	    kex->hash_alg,
 	    kex->client_version_string,
@@ -204,8 +237,8 @@ input_kex_dh_gex_init(int type, u_int32_t seq, struct ssh *ssh)
 	    kex->dh->pub_key,
 	    shared_secret,
 	    hash, &hashlen)) != 0)
-		goto out;
-
+	        goto out;
+#endif
 	/* save session id := H */
 	if (kex->session_id == NULL) {
 		kex->session_id_len = hashlen;
@@ -225,12 +258,23 @@ input_kex_dh_gex_init(int type, u_int32_t seq, struct ssh *ssh)
 	/* destroy_sensitive_data(); */
 
 	/* send server hostkey, DH pubkey 'f' and signed H */
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	const BIGNUM *pub_key;
+	DH_get0_key(kex->dh, &pub_key, NULL);
+	if ((r = sshpkt_start(ssh, SSH2_MSG_KEX_DH_GEX_REPLY)) != 0 ||
+	    (r = sshpkt_put_string(ssh, server_host_key_blob, sbloblen)) != 0 ||
+	    (r = sshpkt_put_bignum2(ssh, pub_key)) != 0 ||     /* f */
+	    (r = sshpkt_put_string(ssh, signature, slen)) != 0 ||
+	    (r = sshpkt_send(ssh)) != 0)
+		goto out;
+#else
 	if ((r = sshpkt_start(ssh, SSH2_MSG_KEX_DH_GEX_REPLY)) != 0 ||
 	    (r = sshpkt_put_string(ssh, server_host_key_blob, sbloblen)) != 0 ||
 	    (r = sshpkt_put_bignum2(ssh, kex->dh->pub_key)) != 0 ||     /* f */
 	    (r = sshpkt_put_string(ssh, signature, slen)) != 0 ||
 	    (r = sshpkt_send(ssh)) != 0)
 		goto out;
+#endif
 
 	if ((r = kex_derive_keys_bn(ssh, hash, hashlen, shared_secret)) == 0)
 		r = kex_send_newkeys(ssh);
diff --git a/monitor.c b/monitor.c
index d4b4b047..6b8809f8 100644
--- a/monitor.c
+++ b/monitor.c
@@ -589,12 +589,20 @@ mm_answer_moduli(int sock, struct sshbuf *m)
 			fatal("%s: buffer error: %s", __func__, ssh_err(r));
 		return (0);
 	} else {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		const BIGNUM *p, *g;
+		DH_get0_pqg(dh, &p, NULL, &g);
 		/* Send first bignum */
 		if ((r = sshbuf_put_u8(m, 1)) != 0 ||
+		    (r = sshbuf_put_bignum2(m, p)) != 0 ||
+		    (r = sshbuf_put_bignum2(m, g)) != 0)
+		        fatal("%s: buffer error: %s", __func__, ssh_err(r));
+#else
+		if ((r = sshbuf_put_u8(m, 1)) != 0 ||
 		    (r = sshbuf_put_bignum2(m, dh->p)) != 0 ||
 		    (r = sshbuf_put_bignum2(m, dh->g)) != 0)
 			fatal("%s: buffer error: %s", __func__, ssh_err(r));
-
+#endif
 		DH_free(dh);
 	}
 	mm_request_send(sock, MONITOR_ANS_MODULI, m);
diff --git a/opacket.c b/opacket.c
index e637d7a7..2b2146a3 100644
--- a/opacket.c
+++ b/opacket.c
@@ -101,13 +101,15 @@ ssh_packet_put_ecpoint(struct ssh *ssh, const EC_GROUP *curve,
 # endif
 #endif /* WITH_OPENSSL */
 
-void
+int
 ssh_packet_send(struct ssh *ssh)
 {
 	int r;
 
 	if ((r = sshpkt_send(ssh)) != 0)
 		fatal("%s: %s", __func__, ssh_err(r));
+
+	return r;
 }
 
 u_int
@@ -277,13 +279,15 @@ packet_write_wait(void)
 		sshpkt_fatal(active_state, __func__, r);
 }
 
-void
+int
 packet_write_poll(void)
 {
 	int r;
 
 	if ((r = ssh_packet_write_poll(active_state)) != 0)
 		sshpkt_fatal(active_state, __func__, r);
+
+	return r;
 }
 
 void
diff --git a/opacket.h b/opacket.h
index f92fe586..039979eb 100644
--- a/opacket.h
+++ b/opacket.h
@@ -12,7 +12,7 @@ void     ssh_packet_put_ecpoint(struct ssh *, const EC_GROUP *, const EC_POINT *
 void     ssh_packet_put_string(struct ssh *, const void *buf, u_int len);
 void     ssh_packet_put_cstring(struct ssh *, const char *str);
 void     ssh_packet_put_raw(struct ssh *, const void *buf, u_int len);
-void     ssh_packet_send(struct ssh *);
+int      ssh_packet_send(struct ssh *);
 
 u_int	 ssh_packet_get_char(struct ssh *);
 u_int	 ssh_packet_get_int(struct ssh *);
@@ -43,7 +43,7 @@ int	 packet_read_seqnr(u_int32_t *);
 int	 packet_read_poll_seqnr(u_int32_t *);
 void	 packet_process_incoming(const char *buf, u_int len);
 void	 packet_write_wait(void);
-void	 packet_write_poll(void);
+int	 packet_write_poll(void);
 void	 packet_read_expect(int expected_type);
 #define packet_set_timeout(timeout, count) \
 	ssh_packet_set_timeout(active_state, (timeout), (count))
diff --git a/openbsd-compat/openssl-compat.c b/openbsd-compat/openssl-compat.c
index 259fccbe..0f175ce2 100644
--- a/openbsd-compat/openssl-compat.c
+++ b/openbsd-compat/openssl-compat.c
@@ -75,7 +75,9 @@ ssh_OpenSSL_add_all_algorithms(void)
 	/* Enable use of crypto hardware */
 	ENGINE_load_builtin_engines();
 	ENGINE_register_all_complete();
+#if OPENSSL_VERSION_NUMBER < 0x10100000UL
 	OPENSSL_config(NULL);
+#endif
 }
 #endif
 
diff --git a/packet.c b/packet.c
index dcf35e6e..e4abc86f 100644
--- a/packet.c
+++ b/packet.c
@@ -283,7 +283,7 @@ struct ssh *
 ssh_packet_set_connection(struct ssh *ssh, int fd_in, int fd_out)
 {
 	struct session_state *state;
-	const struct sshcipher *none = cipher_by_name("none");
+	struct sshcipher *none = cipher_by_name("none");
 	int r;
 
 	if (none == NULL) {
@@ -920,6 +920,24 @@ ssh_set_newkeys(struct ssh *ssh, int mode)
 	return 0;
 }
 
+/* this supports the forced rekeying required for the NONE cipher */
+int rekey_requested = 0;
+void
+packet_request_rekeying(void)
+{
+	rekey_requested = 1;
+}
+
+/* used to determine if pre or post auth when rekeying for aes-ctr
+ * and none cipher switch */
+int
+packet_authentication_state(const struct ssh *ssh)
+{
+	struct session_state *state = ssh->state;
+
+	return state->after_authentication;
+}
+
 #define MAX_PACKETS	(1U<<31)
 static int
 ssh_packet_need_rekeying(struct ssh *ssh, u_int outbound_packet_len)
@@ -946,6 +964,13 @@ ssh_packet_need_rekeying(struct ssh *ssh, u_int outbound_packet_len)
 	if (state->p_send.packets == 0 && state->p_read.packets == 0)
 		return 0;
 
+        /* used to force rekeying when called for by the none
+         * cipher switch and aes-mt-ctr methods -cjr */
+        if (rekey_requested == 1) {
+                rekey_requested = 0;
+                return 1;
+        }
+
 	/* Time-based rekeying */
 	if (state->rekey_interval != 0 &&
 	    (int64_t)state->rekey_time + state->rekey_interval <= monotime())
@@ -2680,3 +2705,10 @@ sshpkt_add_padding(struct ssh *ssh, u_char pad)
 	ssh->state->extra_pad = pad;
 	return 0;
 }
+
+/* need this for the moment for the aes-ctr cipher */
+void *
+ssh_packet_get_send_context(struct ssh *ssh)
+{
+        return ssh->state->send_context;
+}
diff --git a/packet.h b/packet.h
index 170203ca..c109dac3 100644
--- a/packet.h
+++ b/packet.h
@@ -155,6 +155,10 @@ int	 ssh_packet_inc_alive_timeouts(struct ssh *);
 int	 ssh_packet_set_maxsize(struct ssh *, u_int);
 u_int	 ssh_packet_get_maxsize(struct ssh *);
 
+/* for forced packet rekeying post auth */
+void	 packet_request_rekeying(void);
+int	 packet_authentication_state(const struct ssh *);
+
 int	 ssh_packet_get_state(struct ssh *, struct sshbuf *);
 int	 ssh_packet_set_state(struct ssh *, struct sshbuf *);
 
@@ -169,6 +173,9 @@ time_t	 ssh_packet_get_rekey_timeout(struct ssh *);
 
 void	*ssh_packet_get_input(struct ssh *);
 void	*ssh_packet_get_output(struct ssh *);
+void	*ssh_packet_get_receive_context(struct ssh *);
+void	*ssh_packet_get_send_context(struct ssh *);
+void    packet_request_rekeying(void);
 
 /* new API */
 int	sshpkt_start(struct ssh *ssh, u_char type);
diff --git a/progressmeter.c b/progressmeter.c
index fe9bf52e..85667b28 100644
--- a/progressmeter.c
+++ b/progressmeter.c
@@ -69,6 +69,8 @@ static const char *file;	/* name of the file being transferred */
 static off_t start_pos;		/* initial position of transfer */
 static off_t end_pos;		/* ending position of transfer */
 static off_t cur_pos;		/* transfer position as of last refresh */
+static off_t last_pos;
+static off_t max_delta_pos = 0;
 static volatile off_t *counter;	/* progress counter */
 static long stalled;		/* how long we have been stalled */
 static int bytes_per_second;	/* current speed in bytes per second */
@@ -128,12 +130,17 @@ refresh_progress_meter(void)
 	int hours, minutes, seconds;
 	int i, len;
 	int file_len;
+	off_t delta_pos;
 
 	transferred = *counter - (cur_pos ? cur_pos : start_pos);
 	cur_pos = *counter;
 	now = monotime_double();
 	bytes_left = end_pos - cur_pos;
 
+	delta_pos = cur_pos - last_pos;
+	if (delta_pos > max_delta_pos)
+		max_delta_pos = delta_pos;
+
 	if (bytes_left > 0)
 		elapsed = now - last_update;
 	else {
@@ -158,7 +165,7 @@ refresh_progress_meter(void)
 
 	/* filename */
 	buf[0] = '\0';
-	file_len = win_size - 35;
+	file_len = win_size - 45;
 	if (file_len > 0) {
 		len = snprintf(buf, file_len + 1, "\r%s", file);
 		if (len < 0)
@@ -188,6 +195,15 @@ refresh_progress_meter(void)
 	    (off_t)bytes_per_second);
 	strlcat(buf, "/s ", win_size);
 
+	/* instantaneous rate */
+	if (bytes_left > 0)
+		format_rate(buf + strlen(buf), win_size - strlen(buf),
+			    delta_pos);
+	else
+		format_rate(buf + strlen(buf), win_size - strlen(buf),
+			    max_delta_pos);
+	strlcat(buf, "/s ", win_size);
+
 	/* ETA */
 	if (!transferred)
 		stalled += elapsed;
@@ -224,6 +240,7 @@ refresh_progress_meter(void)
 
 	atomicio(vwrite, STDOUT_FILENO, buf, win_size - 1);
 	last_update = now;
+	last_pos = cur_pos;
 }
 
 /*ARGSUSED*/
diff --git a/readconf.c b/readconf.c
index db5f2d54..138b87c9 100644
--- a/readconf.c
+++ b/readconf.c
@@ -67,6 +67,7 @@
 #include "uidswap.h"
 #include "myproposal.h"
 #include "digest.h"
+#include "sshbuf.h"
 
 /* Format of the configuration file:
 
@@ -166,6 +167,9 @@ typedef enum {
 	oHashKnownHosts,
 	oTunnel, oTunnelDevice,
 	oLocalCommand, oPermitLocalCommand, oRemoteCommand,
+	oTcpRcvBufPoll, oTcpRcvBuf, oHPNDisabled, oHPNBufferSize,
+	oNoneEnabled, oNoneSwitch,
+	oDisableMTAES,
 	oVisualHostKey,
 	oKexAlgorithms, oIPQoS, oRequestTTY, oIgnoreUnknown, oProxyUseFdpass,
 	oCanonicalDomains, oCanonicalizeHostname, oCanonicalizeMaxDots,
@@ -293,6 +297,9 @@ static struct {
 	{ "kexalgorithms", oKexAlgorithms },
 	{ "ipqos", oIPQoS },
 	{ "requesttty", oRequestTTY },
+	{ "noneenabled", oNoneEnabled },
+	{ "noneswitch", oNoneSwitch },
+        { "disablemtaes", oDisableMTAES },
 	{ "proxyusefdpass", oProxyUseFdpass },
 	{ "canonicaldomains", oCanonicalDomains },
 	{ "canonicalizefallbacklocal", oCanonicalizeFallbackLocal },
@@ -309,6 +316,11 @@ static struct {
 	{ "ignoreunknown", oIgnoreUnknown },
 	{ "proxyjump", oProxyJump },
 
+	{ "tcprcvbufpoll", oTcpRcvBufPoll },
+	{ "tcprcvbuf", oTcpRcvBuf },
+	{ "hpndisabled", oHPNDisabled },
+	{ "hpnbuffersize", oHPNBufferSize },
+
 	{ NULL, oBadOption }
 };
 
@@ -985,6 +997,42 @@ parse_time:
 		intptr = &options->check_host_ip;
 		goto parse_flag;
 
+	case oHPNDisabled:
+		intptr = &options->hpn_disabled;
+		goto parse_flag;
+
+	case oHPNBufferSize:
+		intptr = &options->hpn_buffer_size;
+		goto parse_int;
+
+	case oTcpRcvBufPoll:
+		intptr = &options->tcp_rcv_buf_poll;
+		goto parse_flag;
+
+	case oNoneEnabled:
+		intptr = &options->none_enabled;
+		goto parse_flag;
+
+        case oDisableMTAES:
+		intptr = &options->disable_multithreaded;
+		goto parse_flag;
+				
+	/*
+	 * We check to see if the command comes from the command
+	 * line or not. If it does then enable it otherwise fail.
+	 *  NONE should never be a default configuration.
+	 */
+	case oNoneSwitch:
+		if (strcmp(filename, "command-line") == 0) {
+			intptr = &options->none_switch;
+			goto parse_flag;
+		} else {
+			error("NoneSwitch is found in %.200s.\nYou may only use this configuration option from the command line", filename);
+			error("Continuing...");
+			debug("NoneSwitch directive found in %.200s.", filename);
+			return 0;
+		}
+
 	case oVerifyHostKeyDNS:
 		intptr = &options->verify_host_key_dns;
 		multistate_ptr = multistate_yesnoask;
@@ -1171,6 +1219,10 @@ parse_int:
 		intptr = &options->connection_attempts;
 		goto parse_int;
 
+	case oTcpRcvBuf:
+		intptr = &options->tcp_rcv_buf;
+		goto parse_int;
+
 	case oCiphers:
 		arg = strdelim(&s);
 		if (!arg || *arg == '\0')
@@ -1888,6 +1940,13 @@ initialize_options(Options * options)
 	options->ip_qos_interactive = -1;
 	options->ip_qos_bulk = -1;
 	options->request_tty = -1;
+	options->none_switch = -1;
+	options->none_enabled = -1;
+        options->disable_multithreaded = -1;
+	options->hpn_disabled = -1;
+	options->hpn_buffer_size = -1;
+	options->tcp_rcv_buf_poll = -1;
+	options->tcp_rcv_buf = -1;
 	options->proxy_use_fdpass = -1;
 	options->ignored_unknown = NULL;
 	options->num_canonical_domains = 0;
@@ -2035,6 +2094,32 @@ fill_default_options(Options * options)
 		options->server_alive_interval = 0;
 	if (options->server_alive_count_max == -1)
 		options->server_alive_count_max = 3;
+	if (options->hpn_disabled == -1)
+		options->hpn_disabled = 0;
+	if (options->hpn_buffer_size > -1) {
+		/* if a user tries to set the size to 0 set it to 1KB */
+		if (options->hpn_buffer_size == 0)
+			options->hpn_buffer_size = 1;
+		/* limit the buffer to SSHBUF_SIZE_MAX (currently 256MB) */
+		if (options->hpn_buffer_size > (SSHBUF_SIZE_MAX / 1024)) {
+			options->hpn_buffer_size = SSHBUF_SIZE_MAX;
+			debug("User requested buffer larger than 256MB. Request reverted to 256MB");
+		} else
+			options->hpn_buffer_size *= 1024;
+		debug("hpn_buffer_size set to %d", options->hpn_buffer_size);
+	}
+	if (options->tcp_rcv_buf == 0)
+		options->tcp_rcv_buf = 1;
+	if (options->tcp_rcv_buf > -1)
+		options->tcp_rcv_buf *=1024;
+	if (options->tcp_rcv_buf_poll == -1)
+		options->tcp_rcv_buf_poll = 1;
+	if (options->none_switch == -1)
+		options->none_switch = 0;
+	if (options->none_enabled == -1)
+		options->none_enabled = 0;
+        if (options->disable_multithreaded == -1)
+		options->disable_multithreaded = 0;
 	if (options->control_master == -1)
 		options->control_master = 0;
 	if (options->control_persist == -1) {
diff --git a/readconf.h b/readconf.h
index c5688781..502e9e24 100644
--- a/readconf.h
+++ b/readconf.h
@@ -50,6 +50,10 @@ typedef struct {
 	int     strict_host_key_checking;	/* Strict host key checking. */
 	int     compression;	/* Compress packets in both directions. */
 	int     tcp_keep_alive;	/* Set SO_KEEPALIVE. */
+	int     tcp_rcv_buf; /* user switch to set tcp recv buffer */
+	int     tcp_rcv_buf_poll; /* Option to poll recv buf every window transfer */
+	int     hpn_disabled;    /* Switch to disable HPN buffer management */
+	int     hpn_buffer_size; /* User definable size for HPN buffer window */
 	int	ip_qos_interactive;	/* IP ToS/DSCP/class for interactive */
 	int	ip_qos_bulk;		/* IP ToS/DSCP/class for bulk traffic */
 	SyslogFacility log_facility;	/* Facility for system logging. */
@@ -111,7 +115,11 @@ typedef struct {
 
 	int	enable_ssh_keysign;
 	int64_t rekey_limit;
+	int     none_switch;    /* Use none cipher */
+	int     none_enabled;   /* Allow none to be used */
+	int     disable_multithreaded; /*disable multithreaded aes-ctr*/
 	int	rekey_interval;
+
 	int	no_host_authentication_for_localhost;
 	int	identities_only;
 	int	server_alive_interval;
diff --git a/regress/unittests/sshkey/test_file.c b/regress/unittests/sshkey/test_file.c
index 99b7e21c..b3f8fe02 100644
--- a/regress/unittests/sshkey/test_file.c
+++ b/regress/unittests/sshkey/test_file.c
@@ -60,9 +60,20 @@ sshkey_file_tests(void)
 	a = load_bignum("rsa_1.param.n");
 	b = load_bignum("rsa_1.param.p");
 	c = load_bignum("rsa_1.param.q");
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+	const BIGNUM *n, *p, *q;
+	RSA_get0_key(k1->rsa, &n, NULL, NULL);
+	RSA_get0_factors(k1->rsa, &p, &q);
+	ASSERT_BIGNUM_EQ(n, a);
+	ASSERT_BIGNUM_EQ(p, b);
+	ASSERT_BIGNUM_EQ(q, c);
+	}
+#else
 	ASSERT_BIGNUM_EQ(k1->rsa->n, a);
 	ASSERT_BIGNUM_EQ(k1->rsa->p, b);
 	ASSERT_BIGNUM_EQ(k1->rsa->q, c);
+#endif
 	BN_free(a);
 	BN_free(b);
 	BN_free(c);
@@ -151,9 +162,20 @@ sshkey_file_tests(void)
 	a = load_bignum("dsa_1.param.g");
 	b = load_bignum("dsa_1.param.priv");
 	c = load_bignum("dsa_1.param.pub");
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+	const BIGNUM *g, *priv_key, *pub_key;
+	DSA_get0_pqg(k1->dsa, NULL, NULL, &g);
+	DSA_get0_key(k1->dsa, &pub_key, &priv_key);
+	ASSERT_BIGNUM_EQ(g, a);
+	ASSERT_BIGNUM_EQ(priv_key, b);
+	ASSERT_BIGNUM_EQ(pub_key, c);
+	}
+#else
 	ASSERT_BIGNUM_EQ(k1->dsa->g, a);
 	ASSERT_BIGNUM_EQ(k1->dsa->priv_key, b);
 	ASSERT_BIGNUM_EQ(k1->dsa->pub_key, c);
+#endif
 	BN_free(a);
 	BN_free(b);
 	BN_free(c);
diff --git a/regress/unittests/sshkey/test_sshkey.c b/regress/unittests/sshkey/test_sshkey.c
index 72367bde..78ab908d 100644
--- a/regress/unittests/sshkey/test_sshkey.c
+++ b/regress/unittests/sshkey/test_sshkey.c
@@ -197,9 +197,20 @@ sshkey_tests(void)
 	k1 = sshkey_new(KEY_RSA);
 	ASSERT_PTR_NE(k1, NULL);
 	ASSERT_PTR_NE(k1->rsa, NULL);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+	const BIGNUM *n, *e, *p;
+	RSA_get0_key(k1->rsa, &n, &e, NULL);
+	RSA_get0_factors(k1->rsa, &p, NULL);
+	ASSERT_PTR_NE(n, NULL);
+	ASSERT_PTR_NE(e, NULL);
+	ASSERT_PTR_EQ(p, NULL);
+	}
+#else
 	ASSERT_PTR_NE(k1->rsa->n, NULL);
-	ASSERT_PTR_NE(k1->rsa->e, NULL);
-	ASSERT_PTR_EQ(k1->rsa->p, NULL);
+        ASSERT_PTR_NE(k1->rsa->e, NULL);
+        ASSERT_PTR_EQ(k1->rsa->p, NULL);
+#endif
 	sshkey_free(k1);
 	TEST_DONE();
 
@@ -207,8 +218,18 @@ sshkey_tests(void)
 	k1 = sshkey_new(KEY_DSA);
 	ASSERT_PTR_NE(k1, NULL);
 	ASSERT_PTR_NE(k1->dsa, NULL);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+	const BIGNUM *g, *priv_key;
+	DSA_get0_pqg(k1->dsa, NULL, NULL, &g);
+	DSA_get0_key(k1->dsa, NULL, &priv_key);
+	ASSERT_PTR_NE(g, NULL);
+	ASSERT_PTR_EQ(priv_key, NULL);
+	}
+#else
 	ASSERT_PTR_NE(k1->dsa->g, NULL);
-	ASSERT_PTR_EQ(k1->dsa->priv_key, NULL);
+        ASSERT_PTR_EQ(k1->dsa->priv_key, NULL);
+#endif
 	sshkey_free(k1);
 	TEST_DONE();
 
@@ -234,9 +255,20 @@ sshkey_tests(void)
 	k1 = sshkey_new_private(KEY_RSA);
 	ASSERT_PTR_NE(k1, NULL);
 	ASSERT_PTR_NE(k1->rsa, NULL);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+	const BIGNUM *n, *e, *p;
+	RSA_get0_key(k1->rsa, &n, &e, NULL);
+	RSA_get0_factors(k1->rsa, &p, NULL);
+	ASSERT_PTR_NE(n, NULL);
+	ASSERT_PTR_NE(e, NULL);
+	ASSERT_PTR_NE(p, NULL);
+	}
+#else
 	ASSERT_PTR_NE(k1->rsa->n, NULL);
-	ASSERT_PTR_NE(k1->rsa->e, NULL);
-	ASSERT_PTR_NE(k1->rsa->p, NULL);
+        ASSERT_PTR_NE(k1->rsa->e, NULL);
+        ASSERT_PTR_NE(k1->rsa->p, NULL);
+#endif
 	ASSERT_INT_EQ(sshkey_add_private(k1), 0);
 	sshkey_free(k1);
 	TEST_DONE();
@@ -245,8 +277,18 @@ sshkey_tests(void)
 	k1 = sshkey_new_private(KEY_DSA);
 	ASSERT_PTR_NE(k1, NULL);
 	ASSERT_PTR_NE(k1->dsa, NULL);
-	ASSERT_PTR_NE(k1->dsa->g, NULL);
-	ASSERT_PTR_NE(k1->dsa->priv_key, NULL);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+	const BIGNUM *g, *priv_key;
+	DSA_get0_pqg(k1->dsa, NULL, NULL, &g);
+	DSA_get0_key(k1->dsa, NULL, &priv_key);
+	ASSERT_PTR_NE(g, NULL);
+	ASSERT_PTR_NE(priv_key, NULL);
+	}
+#else
+        ASSERT_PTR_NE(k1->dsa->g, NULL);
+        ASSERT_PTR_NE(k1->dsa->priv_key, NULL);
+#endif
 	ASSERT_INT_EQ(sshkey_add_private(k1), 0);
 	sshkey_free(k1);
 	TEST_DONE();
@@ -285,18 +327,40 @@ sshkey_tests(void)
 	ASSERT_INT_EQ(sshkey_generate(KEY_RSA, 1024, &kr), 0);
 	ASSERT_PTR_NE(kr, NULL);
 	ASSERT_PTR_NE(kr->rsa, NULL);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+	const BIGNUM *n, *e, *p;
+	RSA_get0_key(kr->rsa, &n, &e, NULL);
+	RSA_get0_factors(kr->rsa, &p, NULL);
+	ASSERT_PTR_NE(n, NULL);
+	ASSERT_PTR_NE(e, NULL);
+	ASSERT_PTR_NE(p, NULL);
+	ASSERT_INT_EQ(BN_num_bits(n), 1024);
+	}
+#else
 	ASSERT_PTR_NE(kr->rsa->n, NULL);
-	ASSERT_PTR_NE(kr->rsa->e, NULL);
-	ASSERT_PTR_NE(kr->rsa->p, NULL);
-	ASSERT_INT_EQ(BN_num_bits(kr->rsa->n), 1024);
+        ASSERT_PTR_NE(kr->rsa->e, NULL);
+        ASSERT_PTR_NE(kr->rsa->p, NULL);
+        ASSERT_INT_EQ(BN_num_bits(kr->rsa->n), 1024);
+#endif
 	TEST_DONE();
 
 	TEST_START("generate KEY_DSA");
 	ASSERT_INT_EQ(sshkey_generate(KEY_DSA, 1024, &kd), 0);
 	ASSERT_PTR_NE(kd, NULL);
 	ASSERT_PTR_NE(kd->dsa, NULL);
-	ASSERT_PTR_NE(kd->dsa->g, NULL);
-	ASSERT_PTR_NE(kd->dsa->priv_key, NULL);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+	const BIGNUM *g, *priv_key;
+	DSA_get0_pqg(kd->dsa, NULL, NULL, &g);
+	DSA_get0_key(kd->dsa, NULL, &priv_key);
+	ASSERT_PTR_NE(g, NULL);
+	ASSERT_PTR_NE(priv_key, NULL);
+	}
+#else
+        ASSERT_PTR_NE(kd->dsa->g, NULL);
+        ASSERT_PTR_NE(kd->dsa->priv_key, NULL);
+#endif
 	TEST_DONE();
 
 #ifdef OPENSSL_HAS_ECC
@@ -323,9 +387,20 @@ sshkey_tests(void)
 	ASSERT_PTR_NE(kr, k1);
 	ASSERT_INT_EQ(k1->type, KEY_RSA);
 	ASSERT_PTR_NE(k1->rsa, NULL);
-	ASSERT_PTR_NE(k1->rsa->n, NULL);
-	ASSERT_PTR_NE(k1->rsa->e, NULL);
-	ASSERT_PTR_EQ(k1->rsa->p, NULL);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+	const BIGNUM *n, *e, *p;
+	RSA_get0_key(k1->rsa, &n, &e, NULL);
+	RSA_get0_factors(k1->rsa, &p, NULL);
+	ASSERT_PTR_NE(n, NULL);
+	ASSERT_PTR_NE(e, NULL);
+	ASSERT_PTR_EQ(p, NULL);
+	}
+#else
+        ASSERT_PTR_NE(k1->rsa->n, NULL);
+        ASSERT_PTR_NE(k1->rsa->e, NULL);
+        ASSERT_PTR_EQ(k1->rsa->p, NULL);
+#endif
 	TEST_DONE();
 
 	TEST_START("equal KEY_RSA/demoted KEY_RSA");
@@ -339,8 +414,18 @@ sshkey_tests(void)
 	ASSERT_PTR_NE(kd, k1);
 	ASSERT_INT_EQ(k1->type, KEY_DSA);
 	ASSERT_PTR_NE(k1->dsa, NULL);
-	ASSERT_PTR_NE(k1->dsa->g, NULL);
-	ASSERT_PTR_EQ(k1->dsa->priv_key, NULL);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+	const BIGNUM *g, *priv_key;
+	DSA_get0_pqg(k1->dsa, NULL, NULL, &g);
+	DSA_get0_key(k1->dsa, NULL, &priv_key);
+	ASSERT_PTR_NE(g, NULL);
+	ASSERT_PTR_EQ(priv_key, NULL);
+	}
+#else
+        ASSERT_PTR_NE(k1->dsa->g, NULL);
+        ASSERT_PTR_EQ(k1->dsa->priv_key, NULL);
+#endif
 	TEST_DONE();
 
 	TEST_START("equal KEY_DSA/demoted KEY_DSA");
diff --git a/sandbox-seccomp-filter.c b/sandbox-seccomp-filter.c
index 12c4ee13..307347d1 100644
--- a/sandbox-seccomp-filter.c
+++ b/sandbox-seccomp-filter.c
@@ -172,6 +172,9 @@ static const struct sock_filter preauth_insns[] = {
 #ifdef __NR_geteuid32
 	SC_ALLOW(__NR_geteuid32),
 #endif
+#ifdef __NR_getpeername /* not defined on archs that go via socketcall(2) */
+	SC_ALLOW(__NR_getpeername),
+#endif
 #ifdef __NR_getpgid
 	SC_ALLOW(__NR_getpgid),
 #endif
@@ -232,6 +235,9 @@ static const struct sock_filter preauth_insns[] = {
 #ifdef __NR_sigprocmask
 	SC_ALLOW(__NR_sigprocmask),
 #endif
+#ifdef __NR_socketcall
+	SC_ALLOW(socketcall),
+#endif
 #ifdef __NR_time
 	SC_ALLOW(__NR_time),
 #endif
diff --git a/scp.c b/scp.c
index 60682c68..c761f40b 100644
--- a/scp.c
+++ b/scp.c
@@ -809,7 +809,7 @@ source(int argc, char **argv)
 	off_t i, statbytes;
 	size_t amt, nr;
 	int fd = -1, haderr, indx;
-	char *last, *name, buf[2048], encname[PATH_MAX];
+	char *last, *name, buf[16384], encname[PATH_MAX];
 	int len;
 
 	for (indx = 0; indx < argc; ++indx) {
diff --git a/servconf.c b/servconf.c
index c0f6af0b..1fd51a0a 100644
--- a/servconf.c
+++ b/servconf.c
@@ -64,6 +64,7 @@
 #include "auth.h"
 #include "myproposal.h"
 #include "digest.h"
+#include "sshbuf.h"
 
 static void add_listen_addr(ServerOptions *, const char *,
     const char *, int);
@@ -173,6 +174,11 @@ initialize_server_options(ServerOptions *options)
 	options->authorized_principals_file = NULL;
 	options->authorized_principals_command = NULL;
 	options->authorized_principals_command_user = NULL;
+	options->tcp_rcv_buf_poll = -1;
+	options->hpn_disabled = -1;
+	options->hpn_buffer_size = -1;
+	options->none_enabled = -1;
+	options->disable_multithreaded = -1;
 	options->ip_qos_interactive = -1;
 	options->ip_qos_bulk = -1;
 	options->version_addendum = NULL;
@@ -255,6 +261,10 @@ void
 fill_default_server_options(ServerOptions *options)
 {
 	u_int i;
+	/* needed for hpn socket tests */
+	int sock;
+	int socksize;
+	int socksizelen = sizeof(int);
 
 	/* Portable-specific options */
 	if (options->use_pam == -1)
@@ -391,6 +401,45 @@ fill_default_server_options(ServerOptions *options)
 	}
 	if (options->permit_tun == -1)
 		options->permit_tun = SSH_TUNMODE_NO;
+	if (options->none_enabled == -1)
+		options->none_enabled = 0;
+	if (options->disable_multithreaded == -1)
+		options->disable_multithreaded = 0;
+	if (options->hpn_disabled == -1)
+		options->hpn_disabled = 0;
+
+	if (options->hpn_buffer_size == -1) {
+		/* option not explicitly set. Now we have to figure out */
+		/* what value to use */
+		if (options->hpn_disabled == 1) {
+			options->hpn_buffer_size = CHAN_SES_WINDOW_DEFAULT;
+		} else {
+			/* get the current RCV size and set it to that */
+			/*create a socket but don't connect it */
+			/* we use that the get the rcv socket size */
+			sock = socket(AF_INET, SOCK_STREAM, 0);
+			getsockopt(sock, SOL_SOCKET, SO_RCVBUF,
+				   &socksize, &socksizelen);
+			close(sock);
+			options->hpn_buffer_size = socksize;
+			debug("HPN Buffer Size: %d", options->hpn_buffer_size);
+		}
+	} else {
+		/* we have to do this in case the user sets both values in a contradictory */
+		/* manner. hpn_disabled overrrides hpn_buffer_size*/
+		if (options->hpn_disabled <= 0) {
+			if (options->hpn_buffer_size == 0)
+				options->hpn_buffer_size = 1;
+			/* limit the maximum buffer to SSHBUF_SIZE_MAX (currently 256MB) */
+			if (options->hpn_buffer_size > (SSHBUF_SIZE_MAX / 1024)) {
+				options->hpn_buffer_size = SSHBUF_SIZE_MAX;
+			} else {
+				options->hpn_buffer_size *= 1024;
+			}
+		} else
+			options->hpn_buffer_size = CHAN_TCP_WINDOW_DEFAULT;
+	}
+
 	if (options->ip_qos_interactive == -1)
 		options->ip_qos_interactive = IPTOS_DSCP_AF21;
 	if (options->ip_qos_bulk == -1)
@@ -469,6 +518,9 @@ typedef enum {
 	sPasswordAuthentication, sKbdInteractiveAuthentication,
 	sListenAddress, sAddressFamily,
 	sPrintMotd, sPrintLastLog, sIgnoreRhosts,
+	sNoneEnabled,
+	sDisableMTAES,
+	sTcpRcvBufPoll, sHPNDisabled, sHPNBufferSize,
 	sX11Forwarding, sX11DisplayOffset, sX11UseLocalhost,
 	sPermitTTY, sStrictModes, sEmptyPasswd, sTCPKeepAlive,
 	sPermitUserEnvironment, sAllowTcpForwarding, sCompression,
@@ -625,6 +677,11 @@ static struct {
 	{ "revokedkeys", sRevokedKeys, SSHCFG_ALL },
 	{ "trustedusercakeys", sTrustedUserCAKeys, SSHCFG_ALL },
 	{ "authorizedprincipalsfile", sAuthorizedPrincipalsFile, SSHCFG_ALL },
+	{ "hpndisabled", sHPNDisabled, SSHCFG_ALL },
+	{ "hpnbuffersize", sHPNBufferSize, SSHCFG_ALL },
+	{ "tcprcvbufpoll", sTcpRcvBufPoll, SSHCFG_ALL },
+	{ "noneenabled", sNoneEnabled, SSHCFG_ALL },
+	{ "disableMTAES", sDisableMTAES, SSHCFG_ALL },
 	{ "kexalgorithms", sKexAlgorithms, SSHCFG_GLOBAL },
 	{ "ipqos", sIPQoS, SSHCFG_ALL },
 	{ "authorizedkeyscommand", sAuthorizedKeysCommand, SSHCFG_ALL },
@@ -680,6 +737,7 @@ parse_token(const char *cp, const char *filename,
 
 	for (i = 0; keywords[i].name; i++)
 		if (strcasecmp(cp, keywords[i].name) == 0) {
+			debug("Config token is %s", keywords[i].name);
 			*flags = keywords[i].flags;
 			return keywords[i].opcode;
 		}
@@ -1400,10 +1458,31 @@ process_server_config_line(ServerOptions *options, char *line,
 		multistate_ptr = multistate_flag;
 		goto parse_multistate;
 
+
+	case sTcpRcvBufPoll:
+		intptr = &options->tcp_rcv_buf_poll;
+		goto parse_flag;
+
+	case sHPNDisabled:
+		intptr = &options->hpn_disabled;
+		goto parse_flag;
+
+	case sHPNBufferSize:
+		intptr = &options->hpn_buffer_size;
+		goto parse_int;
+
 	case sIgnoreUserKnownHosts:
 		intptr = &options->ignore_user_known_hosts;
 		goto parse_flag;
 
+	case sNoneEnabled:
+		intptr = &options->none_enabled;
+		goto parse_flag;
+
+	case sDisableMTAES:
+		intptr = &options->disable_multithreaded;
+		goto parse_flag;
+
 	case sHostbasedAuthentication:
 		intptr = &options->hostbased_authentication;
 		goto parse_flag;
diff --git a/servconf.h b/servconf.h
index 557521d7..81025500 100644
--- a/servconf.h
+++ b/servconf.h
@@ -181,6 +181,13 @@ typedef struct {
 	char   *adm_forced_command;
 
 	int	use_pam;		/* Enable auth via PAM */
+        int     tcp_rcv_buf_poll;       /* poll tcp rcv window in autotuning kernels*/
+	int	hpn_disabled;		/* disable hpn functionality. false by default */
+	int	hpn_buffer_size;	/* set the hpn buffer size - default 3MB */
+
+	int	none_enabled;		/* Enable NONE cipher switch */
+
+        int     disable_multithreaded;  /*disable multithreaded aes-ctr cipher */
 
 	int	permit_tun;
 
diff --git a/serverloop.c b/serverloop.c
index 7be83e2d..7595a2bf 100644
--- a/serverloop.c
+++ b/serverloop.c
@@ -85,6 +85,9 @@ extern Authctxt *the_authctxt;
 extern struct sshauthopt *auth_opts;
 extern int use_privsep;
 
+static u_long stdin_bytes = 0;	/* Number of bytes written to stdin. */
+static u_long fdout_bytes = 0;	/* Number of stdout bytes read from program. */
+
 static int no_more_sessions = 0; /* Disallow further sessions. */
 
 /*
@@ -115,6 +118,20 @@ bind_permitted(int port, uid_t uid)
 }
 
 /*
+ * Returns current time in seconds from Jan 1, 1970 with the maximum
+ * available resolution.
+ */
+
+static double
+get_current_time(void)
+{
+	struct timeval tv;
+	gettimeofday(&tv, NULL);
+	return (double) tv.tv_sec + (double) tv.tv_usec / 1000000.0;
+}
+
+
+/*
  * we write to this pipe if a SIGCHLD is caught in order to avoid
  * the race between select() and child_terminated
  */
@@ -331,6 +348,7 @@ process_input(struct ssh *ssh, fd_set *readset, int connection_in)
 		} else {
 			/* Buffer any received data. */
 			packet_process_incoming(buf, len);
+			fdout_bytes += len;
 		}
 	}
 	return 0;
@@ -344,7 +362,7 @@ process_output(fd_set *writeset, int connection_out)
 {
 	/* Send any buffered packet data to the client. */
 	if (FD_ISSET(connection_out, writeset))
-		packet_write_poll();
+		stdin_bytes += packet_write_poll();
 }
 
 static void
@@ -379,11 +397,13 @@ void
 server_loop2(struct ssh *ssh, Authctxt *authctxt)
 {
 	fd_set *readset = NULL, *writeset = NULL;
+	double start_time, total_time;
 	int max_fd;
 	u_int nalloc = 0, connection_in, connection_out;
 	u_int64_t rekey_timeout_ms = 0;
 
 	debug("Entering interactive session for SSH2.");
+	start_time = get_current_time();
 
 	signal(SIGCHLD, sigchld_handler);
 	child_terminated = 0;
@@ -438,6 +458,13 @@ server_loop2(struct ssh *ssh, Authctxt *authctxt)
 	/* free all channels, no more reads and writes */
 	channel_free_all(ssh);
 
+	/* write final data to log */
+	total_time = get_current_time() - start_time;
+	logit("SSH: Server;LType: Throughput;Remote: %s-%d;IN: %lu;OUT: %lu;Duration: %.1f;tPut_in: %.1f;tPut_out: %.1f",
+	      ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
+	      stdin_bytes, fdout_bytes, total_time, stdin_bytes / total_time,
+	      fdout_bytes / total_time);
+
 	/* free remaining sessions, e.g. remove wtmp entries */
 	session_destroy_all(ssh, NULL);
 }
@@ -562,7 +589,8 @@ server_request_tun(struct ssh *ssh)
 	debug("Tunnel forwarding using interface %s", ifname);
 
 	c = channel_new(ssh, "tun", SSH_CHANNEL_OPEN, sock, sock, -1,
-	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, "tun", 1);
+			options.hpn_disabled ? CHAN_TCP_WINDOW_DEFAULT : options.hpn_buffer_size,                   
+			CHAN_TCP_PACKET_DEFAULT, 0, "tun", 1);
 	c->datagram = 1;
 #if defined(SSH_TUN_FILTER)
 	if (mode == SSH_TUNMODE_POINTOPOINT)
@@ -611,6 +639,8 @@ server_request_session(struct ssh *ssh)
 	c = channel_new(ssh, "session", SSH_CHANNEL_LARVAL,
 	    -1, -1, -1, /*window size*/0, CHAN_SES_PACKET_DEFAULT,
 	    0, "server-session", 1);
+	if ((options.tcp_rcv_buf_poll) && (!options.hpn_disabled))
+		c->dynamic_window = 1;
 	if (session_open(the_authctxt, c->self) != 1) {
 		debug("session open failed, free channel %d", c->self);
 		channel_free(ssh, c);
diff --git a/session.c b/session.c
index f2cf5200..63e7daae 100644
--- a/session.c
+++ b/session.c
@@ -226,6 +226,7 @@ auth_input_request_forwarding(struct ssh *ssh, struct passwd * pw)
 		goto authsock_err;
 
 	/* Allocate a channel for the authentication agent socket. */
+	/* this shouldn't matter if its hpn or not - cjr */
 	nc = channel_new(ssh, "auth socket",
 	    SSH_CHANNEL_AUTH_SOCKET, sock, sock, -1,
 	    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,
@@ -2172,10 +2173,11 @@ session_set_fds(struct ssh *ssh, Session *s,
 	 */
 	if (s->chanid == -1)
 		fatal("no channel for session %d", s->self);
-	channel_set_fds(ssh, s->chanid,
-	    fdout, fdin, fderr,
-	    ignore_fderr ? CHAN_EXTENDED_IGNORE : CHAN_EXTENDED_READ,
-	    1, is_tty, CHAN_SES_WINDOW_DEFAULT);
+        channel_set_fds(ssh, s->chanid,
+			fdout, fdin, fderr,
+			ignore_fderr ? CHAN_EXTENDED_IGNORE : CHAN_EXTENDED_READ,
+			1, is_tty,
+            options.hpn_disabled ? CHAN_SES_WINDOW_DEFAULT : options.hpn_buffer_size);
 }
 
 /*
diff --git a/sftp.1 b/sftp.1
index a25d3890..c940f65b 100644
--- a/sftp.1
+++ b/sftp.1
@@ -264,7 +264,8 @@ diagnostic messages from
 Specify how many requests may be outstanding at any one time.
 Increasing this may slightly improve file transfer speed
 but will increase memory usage.
-The default is 64 outstanding requests.
+The default is 256 outstanding requests providing for 8MB
+of outstanding data with a 32KB buffer.
 .It Fl r
 Recursively copy entire directories when uploading and downloading.
 Note that
diff --git a/sftp.c b/sftp.c
index d068f7e0..64e762cc 100644
--- a/sftp.c
+++ b/sftp.c
@@ -72,7 +72,7 @@ typedef void EditLine;
 #include "sftp-client.h"
 
 #define DEFAULT_COPY_BUFLEN	32768	/* Size of buffer for up/download */
-#define DEFAULT_NUM_REQUESTS	64	/* # concurrent outstanding requests */
+#define DEFAULT_NUM_REQUESTS	256	/* # concurrent outstanding requests */
 
 /* File to read commands from */
 FILE* infile;
diff --git a/ssh-dss.c b/ssh-dss.c
index 9f832ee2..ac784776 100644
--- a/ssh-dss.c
+++ b/ssh-dss.c
@@ -53,6 +53,9 @@ ssh_dss_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
 	DSA_SIG *sig = NULL;
 	u_char digest[SSH_DIGEST_MAX_LENGTH], sigblob[SIGBLOB_LEN];
 	size_t rlen, slen, len, dlen = ssh_digest_bytes(SSH_DIGEST_SHA1);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	const BIGNUM *r, *s;
+#endif
 	struct sshbuf *b = NULL;
 	int ret = SSH_ERR_INVALID_ARGUMENT;
 
@@ -76,16 +79,27 @@ ssh_dss_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
 		goto out;
 	}
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	DSA_SIG_get0(sig, &r, &s);
+	rlen = BN_num_bytes(r);
+	slen = BN_num_bytes(s);
+#else
 	rlen = BN_num_bytes(sig->r);
 	slen = BN_num_bytes(sig->s);
+#endif
 	if (rlen > INTBLOB_LEN || slen > INTBLOB_LEN) {
 		ret = SSH_ERR_INTERNAL_ERROR;
 		goto out;
 	}
 	explicit_bzero(sigblob, SIGBLOB_LEN);
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	BN_bn2bin(r, sigblob + SIGBLOB_LEN - INTBLOB_LEN - rlen);
+	BN_bn2bin(s, sigblob + SIGBLOB_LEN - slen);
+#else
 	BN_bn2bin(sig->r, sigblob + SIGBLOB_LEN - INTBLOB_LEN - rlen);
 	BN_bn2bin(sig->s, sigblob + SIGBLOB_LEN - slen);
-
+#endif
 	if ((b = sshbuf_new()) == NULL) {
 		ret = SSH_ERR_ALLOC_FAIL;
 		goto out;
@@ -154,17 +168,40 @@ ssh_dss_verify(const struct sshkey *key,
 	}
 
 	/* parse signature */
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+	BIGNUM *r=NULL, *s=NULL;
 	if ((sig = DSA_SIG_new()) == NULL ||
-	    (sig->r = BN_new()) == NULL ||
-	    (sig->s = BN_new()) == NULL) {
+	    (r = BN_new()) == NULL ||
+	    (s = BN_new()) == NULL) {
 		ret = SSH_ERR_ALLOC_FAIL;
+		BN_free(r);
+		BN_free(s);
 		goto out;
 	}
-	if ((BN_bin2bn(sigblob, INTBLOB_LEN, sig->r) == NULL) ||
-	    (BN_bin2bn(sigblob+ INTBLOB_LEN, INTBLOB_LEN, sig->s) == NULL)) {
+	if ((BN_bin2bn(sigblob, INTBLOB_LEN, r) == NULL) ||
+	    (BN_bin2bn(sigblob+ INTBLOB_LEN, INTBLOB_LEN, s) == NULL)) {
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		BN_free(r);
+		BN_free(s);
 		goto out;
 	}
+	DSA_SIG_set0(sig, r, s);
+	r = s = NULL;
+	}
+#else
+	if ((sig = DSA_SIG_new()) == NULL ||
+	    (sig->r = BN_new()) == NULL ||
+	    (sig->s = BN_new()) == NULL) {
+	  ret = SSH_ERR_ALLOC_FAIL;
+	  goto out;
+	}
+	if ((BN_bin2bn(sigblob, INTBLOB_LEN, sig->r) == NULL) ||
+	    (BN_bin2bn(sigblob+ INTBLOB_LEN, INTBLOB_LEN, sig->s) == NULL)) {
+	  ret = SSH_ERR_LIBCRYPTO_ERROR;
+	  goto out;
+	}
+#endif
 
 	/* sha1 the data */
 	if ((ret = ssh_digest_memory(SSH_DIGEST_SHA1, data, datalen,
diff --git a/ssh-ecdsa.c b/ssh-ecdsa.c
index 3d3b78d7..b9e5a154 100644
--- a/ssh-ecdsa.c
+++ b/ssh-ecdsa.c
@@ -80,9 +80,19 @@ ssh_ecdsa_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
 		ret = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
+#if OPENSSL_VERSION_NUMBER >=0x10100000UL
+	{
+		const BIGNUM *r, *s;
+		ECDSA_SIG_get0(sig, &r, &s);
+		if ((ret = sshbuf_put_bignum2(bb, r)) != 0 ||
+		    (ret = sshbuf_put_bignum2(bb, s)) != 0)
+			goto out;
+	}
+#else
 	if ((ret = sshbuf_put_bignum2(bb, sig->r)) != 0 ||
 	    (ret = sshbuf_put_bignum2(bb, sig->s)) != 0)
 		goto out;
+#endif
 	if ((ret = sshbuf_put_cstring(b, sshkey_ssh_name_plain(key))) != 0 ||
 	    (ret = sshbuf_put_stringb(b, bb)) != 0)
 		goto out;
@@ -150,11 +160,35 @@ ssh_ecdsa_verify(const struct sshkey *key,
 		ret = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+		BIGNUM *r=NULL, *s=NULL;
+		if ((r = BN_new()) == NULL ||
+		    (s = BN_new()) == NULL) {
+			ret = SSH_ERR_ALLOC_FAIL;
+			goto out_rs;
+		}
+		if (sshbuf_get_bignum2(sigbuf, r) != 0 ||
+		    sshbuf_get_bignum2(sigbuf, s) != 0) {
+			ret = SSH_ERR_INVALID_FORMAT;
+			goto out_rs;
+		}
+		if (ECDSA_SIG_set0(sig, r, s) == 0) {
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+		out_rs:
+			BN_free(r);
+			BN_free(s);
+			goto out;
+		}
+		r = s = NULL;
+	}
+#else
 	if (sshbuf_get_bignum2(sigbuf, sig->r) != 0 ||
 	    sshbuf_get_bignum2(sigbuf, sig->s) != 0) {
 		ret = SSH_ERR_INVALID_FORMAT;
 		goto out;
 	}
+#endif
 	if (sshbuf_len(sigbuf) != 0) {
 		ret = SSH_ERR_UNEXPECTED_TRAILING_DATA;
 		goto out;
diff --git a/ssh-keygen.c b/ssh-keygen.c
index 22860ad9..9ec0744f 100644
--- a/ssh-keygen.c
+++ b/ssh-keygen.c
@@ -494,11 +494,41 @@ do_convert_private_ssh2_from_blob(u_char *blob, u_int blen)
 
 	switch (key->type) {
 	case KEY_DSA:
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	        {
+		BIGNUM *p=NULL, *g=NULL, *q=NULL, *pub_key=NULL, *priv_key=NULL;
+		if ((p=BN_new()) == NULL ||
+		    (g=BN_new()) == NULL ||
+		    (q=BN_new()) == NULL ||
+		    (pub_key=BN_new()) == NULL ||
+		    (priv_key=BN_new()) == NULL) {
+			BN_free(p);
+			BN_free(g);
+			BN_free(q);
+			BN_free(pub_key);
+			BN_free(priv_key);
+			return NULL;
+		}
+		buffer_get_bignum_bits(b, p);
+		buffer_get_bignum_bits(b, g);
+		buffer_get_bignum_bits(b, q);
+		buffer_get_bignum_bits(b, pub_key);
+		buffer_get_bignum_bits(b, priv_key);
+		if (DSA_set0_pqg(key->dsa, p, q, g) == 0 ||
+		    DSA_set0_key(key->dsa, pub_key, priv_key) == 0) {
+			fatal("failed to set DSA key");
+			BN_free(p); BN_free(g); BN_free(q);
+			BN_free(pub_key); BN_free(priv_key);
+			return NULL;
+		}
+		}
+#else
 		buffer_get_bignum_bits(b, key->dsa->p);
 		buffer_get_bignum_bits(b, key->dsa->g);
 		buffer_get_bignum_bits(b, key->dsa->q);
 		buffer_get_bignum_bits(b, key->dsa->pub_key);
 		buffer_get_bignum_bits(b, key->dsa->priv_key);
+#endif
 		break;
 	case KEY_RSA:
 		if ((r = sshbuf_get_u8(b, &e1)) != 0 ||
@@ -515,7 +545,55 @@ do_convert_private_ssh2_from_blob(u_char *blob, u_int blen)
 			e += e3;
 			debug("e %lx", e);
 		}
-		if (!BN_set_word(key->rsa->e, e)) {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		{
+		BIGNUM *rsa_e = NULL;
+		BIGNUM *d=NULL, *n=NULL, *iqmp=NULL, *q=NULL, *p=NULL;
+		BIGNUM *dmp1=NULL, *dmq1=NULL; /* dummy input to set in RSA_set0_crt_params */
+		rsa_e = BN_new();
+		if (!rsa_e || !BN_set_word(rsa_e, e)) {
+			if (rsa_e) BN_free(rsa_e);
+			sshbuf_free(b);
+			sshkey_free(key);
+			return NULL;
+		}
+		if ((d=BN_new()) == NULL ||
+		    (n=BN_new()) == NULL ||
+		    (iqmp=BN_new()) == NULL ||
+		    (q=BN_new()) == NULL ||
+		    (p=BN_new()) == NULL ||
+		    (dmp1=BN_new()) == NULL ||
+		    (dmq1=BN_new()) == NULL) {
+			BN_free(d); BN_free(n); BN_free(iqmp);
+			BN_free(q); BN_free(p);
+			BN_free(dmp1); BN_free(dmq1);
+			return NULL;
+		}
+		BN_clear(dmp1); BN_clear(dmq1);
+		buffer_get_bignum_bits(b, d);
+		buffer_get_bignum_bits(b, n);
+		buffer_get_bignum_bits(b, iqmp);
+		buffer_get_bignum_bits(b, q);
+		buffer_get_bignum_bits(b, p);
+		if (RSA_set0_key(key->rsa, n, rsa_e, d) == 0)
+			goto null;
+		n = d = NULL;
+		if (RSA_set0_factors(key->rsa, p, q) == 0)
+			goto null;
+		p = q = NULL;
+		/* dmp1, dmq1 should not be NULL for initial set0 */
+		if (RSA_set0_crt_params(key->rsa, dmp1, dmq1, iqmp) == 0) {
+ null:
+			fatal("Failed to set RSA parameters");
+			BN_free(d); BN_free(n); BN_free(iqmp);
+			BN_free(q); BN_free(p);
+			BN_free(dmp1); BN_free(dmq1);
+			return NULL;
+		}
+		dmp1 = dmq1 = iqmp = NULL;
+		}
+#else
+                if (!BN_set_word(key->rsa->e, e)) {
 			sshbuf_free(b);
 			sshkey_free(key);
 			return NULL;
@@ -525,6 +603,7 @@ do_convert_private_ssh2_from_blob(u_char *blob, u_int blen)
 		buffer_get_bignum_bits(b, key->rsa->iqmp);
 		buffer_get_bignum_bits(b, key->rsa->q);
 		buffer_get_bignum_bits(b, key->rsa->p);
+#endif
 		if ((r = ssh_rsa_generate_additional_parameters(key)) != 0)
 			fatal("generate RSA parameters failed: %s", ssh_err(r));
 		break;
@@ -634,7 +713,12 @@ do_convert_from_pkcs8(struct sshkey **k, int *private)
 		    identity_file);
 	}
 	fclose(fp);
-	switch (EVP_PKEY_type(pubkey->type)) {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	switch (EVP_PKEY_type(EVP_PKEY_id(pubkey)))
+#else
+        switch (EVP_PKEY_type(pubkey->type))
+#endif
+	{
 	case EVP_PKEY_RSA:
 		if ((*k = sshkey_new(KEY_UNSPEC)) == NULL)
 			fatal("sshkey_new failed");
@@ -657,8 +741,13 @@ do_convert_from_pkcs8(struct sshkey **k, int *private)
 		break;
 #endif
 	default:
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
 		fatal("%s: unsupported pubkey type %d", __func__,
-		    EVP_PKEY_type(pubkey->type));
+		      EVP_PKEY_type(EVP_PKEY_id(pubkey)));
+#else
+		fatal("%s: unsupported pubkey type %d", __func__,
+		      EVP_PKEY_type(pubkey->type));
+#endif
 	}
 	EVP_PKEY_free(pubkey);
 	return;
diff --git a/ssh-pkcs11-client.c b/ssh-pkcs11-client.c
index 028b272c..5d5eef56 100644
--- a/ssh-pkcs11-client.c
+++ b/ssh-pkcs11-client.c
@@ -156,12 +156,22 @@ pkcs11_rsa_private_encrypt(int flen, const u_char *from, u_char *to, RSA *rsa,
 static int
 wrap_key(RSA *rsa)
 {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	static RSA_METHOD *helper_rsa;
+
+	if ((helper_rsa = RSA_meth_dup(RSA_get_default_method())) == NULL)
+		return (-1); /* XXX but caller isn't checking */
+	RSA_meth_set1_name(helper_rsa, "ssh-pkcs11-helper");
+	RSA_meth_set_priv_enc(helper_rsa, pkcs11_rsa_private_encrypt);
+	RSA_set_method(rsa, helper_rsa);
+#else
 	static RSA_METHOD helper_rsa;
 
 	memcpy(&helper_rsa, RSA_get_default_method(), sizeof(helper_rsa));
 	helper_rsa.name = "ssh-pkcs11-helper";
 	helper_rsa.rsa_priv_enc = pkcs11_rsa_private_encrypt;
 	RSA_set_method(rsa, &helper_rsa);
+#endif
 	return (0);
 }
 
diff --git a/ssh-pkcs11.c b/ssh-pkcs11.c
index 65a7b589..9dfc79b3 100644
--- a/ssh-pkcs11.c
+++ b/ssh-pkcs11.c
@@ -67,7 +67,11 @@ struct pkcs11_key {
 	struct pkcs11_provider	*provider;
 	CK_ULONG		slotidx;
 	int			(*orig_finish)(RSA *rsa);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	RSA_METHOD		*rsa_method;
+#else
 	RSA_METHOD		rsa_method;
+#endif
 	char			*keyid;
 	int			keyid_len;
 };
@@ -326,6 +330,15 @@ pkcs11_rsa_wrap(struct pkcs11_provider *provider, CK_ULONG slotidx,
 		k11->keyid = xmalloc(k11->keyid_len);
 		memcpy(k11->keyid, keyid_attrib->pValue, k11->keyid_len);
 	}
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	k11->orig_finish = RSA_meth_get_finish(def);
+	if ((k11->rsa_method = RSA_meth_new("pkcs11", RSA_meth_get_flags(def))) == NULL)
+		return -1;
+	RSA_meth_set_priv_enc(k11->rsa_method, pkcs11_rsa_private_encrypt);
+	RSA_meth_set_priv_dec(k11->rsa_method, pkcs11_rsa_private_decrypt);
+	RSA_meth_set_finish(k11->rsa_method, pkcs11_rsa_finish);
+	RSA_set_method(rsa, k11->rsa_method);
+#else
 	k11->orig_finish = def->finish;
 	memcpy(&k11->rsa_method, def, sizeof(k11->rsa_method));
 	k11->rsa_method.name = "pkcs11";
@@ -333,7 +346,9 @@ pkcs11_rsa_wrap(struct pkcs11_provider *provider, CK_ULONG slotidx,
 	k11->rsa_method.rsa_priv_dec = pkcs11_rsa_private_decrypt;
 	k11->rsa_method.finish = pkcs11_rsa_finish;
 	RSA_set_method(rsa, &k11->rsa_method);
+#endif
 	RSA_set_app_data(rsa, k11);
+
 	return (0);
 }
 
@@ -512,10 +527,26 @@ pkcs11_fetch_keys_filter(struct pkcs11_provider *p, CK_ULONG slotidx,
 			if ((rsa = RSA_new()) == NULL) {
 				error("RSA_new failed");
 			} else {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+				BIGNUM *n=NULL, *e=NULL;
+				n = BN_new();
+				e = BN_new();
+				if (n == NULL || e == NULL)
+					error("BN_new alloc failed");
+				if (BN_bin2bn(attribs[1].pValue,
+					      attribs[1].ulValueLen, n) == NULL ||
+				    BN_bin2bn(attribs[2].pValue,
+					      attribs[2].ulValueLen, e) == NULL)
+					error("BN_bin2bn failed");
+				if (RSA_set0_key(rsa, n, e, NULL) == 0)
+					error("RSA_set0_key failed");
+				n = e = NULL;
+#else
 				rsa->n = BN_bin2bn(attribs[1].pValue,
-				    attribs[1].ulValueLen, NULL);
+						   attribs[1].ulValueLen, NULL);
 				rsa->e = BN_bin2bn(attribs[2].pValue,
-				    attribs[2].ulValueLen, NULL);
+						   attribs[2].ulValueLen, NULL);
+#endif
 			}
 		} else {
 			cp = attribs[2].pValue;
@@ -524,18 +555,40 @@ pkcs11_fetch_keys_filter(struct pkcs11_provider *p, CK_ULONG slotidx,
 			} else if (d2i_X509(&x509, &cp, attribs[2].ulValueLen)
 			    == NULL) {
 				error("d2i_X509 failed");
-			} else if ((evp = X509_get_pubkey(x509)) == NULL ||
-			    evp->type != EVP_PKEY_RSA ||
-			    evp->pkey.rsa == NULL) {
+			}
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+			else if ((evp = X509_get_pubkey(x509)) == NULL ||
+				 EVP_PKEY_id(evp) != EVP_PKEY_RSA ||
+				 EVP_PKEY_get0_RSA(evp) == NULL)
+			{
+				debug("X509_get_pubkey failed or no rsa");
+			} else if
+					((rsa = RSAPublicKey_dup(EVP_PKEY_get0_RSA(evp)))
+					 == NULL) {
+				error("RSAPublicKey_dup");
+			}
+#else
+			else if ((evp = X509_get_pubkey(x509)) == NULL ||
+				                             evp->type != EVP_PKEY_RSA ||
+				 evp->pkey.rsa == NULL) {
 				debug("X509_get_pubkey failed or no rsa");
 			} else if ((rsa = RSAPublicKey_dup(evp->pkey.rsa))
-			    == NULL) {
+			   == NULL) {
 				error("RSAPublicKey_dup");
 			}
+#endif
 			X509_free(x509);
 		}
-		if (rsa && rsa->n && rsa->e &&
-		    pkcs11_rsa_wrap(p, slotidx, &attribs[0], rsa) == 0) {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		const BIGNUM *n, *e;
+		RSA_get0_key(rsa, &n, &e, NULL);
+		if (rsa && n && e &&
+		    pkcs11_rsa_wrap(p, slotidx, &attribs[0], rsa) == 0)
+#else
+			if (rsa && rsa->n && rsa->e &&
+			    pkcs11_rsa_wrap(p, slotidx, &attribs[0], rsa) == 0)
+#endif
+			{
 			if ((key = sshkey_new(KEY_UNSPEC)) == NULL)
 				fatal("sshkey_new failed");
 			key->rsa = rsa;
diff --git a/ssh-rsa.c b/ssh-rsa.c
index 1756315b..7c97163e 100644
--- a/ssh-rsa.c
+++ b/ssh-rsa.c
@@ -108,7 +108,9 @@ ssh_rsa_generate_additional_parameters(struct sshkey *key)
 {
 	BIGNUM *aux = NULL;
 	BN_CTX *ctx = NULL;
+#if OPENSSL_VERSION_NUMBER < 0x10100000UL
 	BIGNUM d;
+#endif
 	int r;
 
 	if (key == NULL || key->rsa == NULL ||
@@ -122,7 +124,29 @@ ssh_rsa_generate_additional_parameters(struct sshkey *key)
 		goto out;
 	}
 	BN_set_flags(aux, BN_FLG_CONSTTIME);
-
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+	const BIGNUM *q, *d, *p;
+	BIGNUM *dmq1=NULL, *dmp1=NULL;
+	if ((dmq1 = BN_new()) == NULL ||
+	    (dmp1 = BN_new()) == NULL ) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	RSA_get0_key(key->rsa, NULL, NULL, &d);
+	RSA_get0_factors(key->rsa, &p, &q);
+	if ((BN_sub(aux, q, BN_value_one()) == 0) ||
+	    (BN_mod(dmq1, d, aux, ctx) == 0) ||
+	    (BN_sub(aux, p, BN_value_one()) == 0) ||
+	    (BN_mod(dmp1, d, aux, ctx) == 0) ||
+	    RSA_set0_crt_params(key->rsa, dmp1, dmq1, NULL) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		BN_clear_free(dmp1);
+		BN_clear_free(dmq1);
+		goto out;
+	}
+	}
+#else
 	BN_init(&d);
 	BN_with_flags(&d, key->rsa->d, BN_FLG_CONSTTIME);
 
@@ -130,9 +154,10 @@ ssh_rsa_generate_additional_parameters(struct sshkey *key)
 	    (BN_mod(key->rsa->dmq1, &d, aux, ctx) == 0) ||
 	    (BN_sub(aux, key->rsa->p, BN_value_one()) == 0) ||
 	    (BN_mod(key->rsa->dmp1, &d, aux, ctx) == 0)) {
-		r = SSH_ERR_LIBCRYPTO_ERROR;
-		goto out;
+	  r = SSH_ERR_LIBCRYPTO_ERROR;
+	  goto out;
 	}
+#endif
 	r = 0;
  out:
 	BN_clear_free(aux);
@@ -163,7 +188,11 @@ ssh_rsa_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
 	if (key == NULL || key->rsa == NULL || hash_alg == -1 ||
 	    sshkey_type_plain(key->type) != KEY_RSA)
 		return SSH_ERR_INVALID_ARGUMENT;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	if (RSA_bits(key->rsa) < SSH_RSA_MINIMUM_MODULUS_SIZE)
+#else
 	if (BN_num_bits(key->rsa->n) < SSH_RSA_MINIMUM_MODULUS_SIZE)
+#endif
 		return SSH_ERR_KEY_LENGTH;
 	slen = RSA_size(key->rsa);
 	if (slen <= 0 || slen > SSHBUF_MAX_BIGNUM)
@@ -235,7 +264,11 @@ ssh_rsa_verify(const struct sshkey *key,
 	    sshkey_type_plain(key->type) != KEY_RSA ||
 	    sig == NULL || siglen == 0)
 		return SSH_ERR_INVALID_ARGUMENT;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	if (RSA_bits(key->rsa) < SSH_RSA_MINIMUM_MODULUS_SIZE)
+#else
 	if (BN_num_bits(key->rsa->n) < SSH_RSA_MINIMUM_MODULUS_SIZE)
+#endif
 		return SSH_ERR_KEY_LENGTH;
 
 	if ((b = sshbuf_from(sig, siglen)) == NULL)
diff --git a/ssh.c b/ssh.c
index ce628848..937f11e6 100644
--- a/ssh.c
+++ b/ssh.c
@@ -947,6 +947,10 @@ main(int ac, char **av)
 			break;
 		case 'T':
 			options.request_tty = REQUEST_TTY_NO;
+			/* ensure that the user doesn't try to backdoor a */
+			/* null cipher switch on an interactive session */
+			/* so explicitly disable it no matter what */
+			options.none_switch=0;
 			break;
 		case 'o':
 			line = xstrdup(optarg);
@@ -1557,6 +1561,8 @@ control_persist_detach(void)
 	setproctitle("%s [mux]", options.control_path);
 }
 
+extern const EVP_CIPHER *evp_aes_ctr_mt(void);
+
 /* Do fork() after authentication. Used by "ssh -f" */
 static void
 fork_postauth(void)
@@ -1784,6 +1790,78 @@ ssh_session2_setup(struct ssh *ssh, int id, int success, void *arg)
 	    NULL, fileno(stdin), command, environ);
 }
 
+static void
+hpn_options_init(void)
+{
+	/*
+	 * We need to check to see if what they want to do about buffer
+	 * sizes here. In a hpn to nonhpn connection we want to limit
+	 * the window size to something reasonable in case the far side
+	 * has the large window bug. In hpn to hpn connection we want to
+	 * use the max window size but allow the user to override it
+	 * lastly if they disabled hpn then use the ssh std window size.
+	 *
+	 * So why don't we just do a getsockopt() here and set the
+	 * ssh window to that? In the case of a autotuning receive
+	 * window the window would get stuck at the initial buffer
+	 * size generally less than 96k. Therefore we need to set the
+	 * maximum ssh window size to the maximum hpn buffer size
+	 * unless the user has specifically set the tcprcvbufpoll
+	 * to no. In which case we *can* just set the window to the
+	 * minimum of the hpn buffer size and tcp receive buffer size.
+	 */
+
+	if (tty_flag)
+		options.hpn_buffer_size = CHAN_SES_WINDOW_DEFAULT;
+	else
+		options.hpn_buffer_size = 2 * 1024 * 1024;
+
+	if (datafellows & SSH_BUG_LARGEWINDOW) {
+		debug("HPN to Non-HPN Connection");
+	} else {
+		int sock, socksize;
+		socklen_t socksizelen;
+		if (options.tcp_rcv_buf_poll <= 0) {
+			sock = socket(AF_INET, SOCK_STREAM, 0);
+			socksizelen = sizeof(socksize);
+			getsockopt(sock, SOL_SOCKET, SO_RCVBUF,
+				   &socksize, &socksizelen);
+			close(sock);
+			debug("socksize %d", socksize);
+			options.hpn_buffer_size = socksize;
+			debug("HPNBufferSize set to TCP RWIN: %d", options.hpn_buffer_size);
+		} else {
+			if (options.tcp_rcv_buf > 0) {
+				/*
+				 * Create a socket but don't connect it:
+				 * we use that the get the rcv socket size
+				 */
+				sock = socket(AF_INET, SOCK_STREAM, 0);
+				/*
+				 * If they are using the tcp_rcv_buf option,
+				 * attempt to set the buffer size to that.
+				 */
+				if (options.tcp_rcv_buf) {
+					socksizelen = sizeof(options.tcp_rcv_buf);
+					setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
+						   &options.tcp_rcv_buf, socksizelen);
+				}
+				socksizelen = sizeof(socksize);
+				getsockopt(sock, SOL_SOCKET, SO_RCVBUF,
+					   &socksize, &socksizelen);
+				close(sock);
+				debug("socksize %d", socksize);
+				options.hpn_buffer_size = socksize;
+				debug("HPNBufferSize set to user TCPRcvBuf: %d", options.hpn_buffer_size);
+			}
+		}
+	}
+
+	debug("Final hpn_buffer_size = %d", options.hpn_buffer_size);
+
+	channel_set_hpn(options.hpn_disabled, options.hpn_buffer_size);
+}
+
 /* open new channel for a session */
 static int
 ssh_session2_open(struct ssh *ssh)
@@ -1810,9 +1888,11 @@ ssh_session2_open(struct ssh *ssh)
 	if (!isatty(err))
 		set_nonblock(err);
 
-	window = CHAN_SES_WINDOW_DEFAULT;
+	window = options.hpn_buffer_size;
+
 	packetmax = CHAN_SES_PACKET_DEFAULT;
 	if (tty_flag) {
+		window = CHAN_SES_WINDOW_DEFAULT;
 		window >>= 1;
 		packetmax >>= 1;
 	}
@@ -1821,6 +1901,10 @@ ssh_session2_open(struct ssh *ssh)
 	    window, packetmax, CHAN_EXTENDED_WRITE,
 	    "client-session", /*nonblock*/0);
 
+	if ((options.tcp_rcv_buf_poll > 0) && (!options.hpn_disabled)) {
+		c->dynamic_window = 1;
+		debug("Enabled Dynamic Window Scaling");
+	}
 	debug3("%s: channel_new: %d", __func__, c->self);
 
 	channel_send_open(ssh, c->self);
@@ -1837,6 +1921,13 @@ ssh_session2(struct ssh *ssh, struct passwd *pw)
 	int devnull, id = -1;
 	char *cp, *tun_fwd_ifname = NULL;
 
+	/*
+	 * We need to initialize this early because the forwarding logic below
+	 * might open channels that use the hpn buffer sizes.  We can't send a
+	 * window of -1 (the default) to the server as it breaks things.
+	 */
+	hpn_options_init();
+
 	/* XXX should be pre-session */
 	if (!options.control_persist)
 		ssh_init_stdio_forwarding(ssh);
diff --git a/sshbuf.h b/sshbuf.h
index a43598ca..785ff287 100644
--- a/sshbuf.h
+++ b/sshbuf.h
@@ -28,7 +28,7 @@
 # endif /* OPENSSL_HAS_ECC */
 #endif /* WITH_OPENSSL */
 
-#define SSHBUF_SIZE_MAX		0x8000000	/* Hard maximum size */
+#define SSHBUF_SIZE_MAX		0xF000000	/* Hard maximum size 256MB */
 #define SSHBUF_REFS_MAX		0x100000	/* Max child buffers */
 #define SSHBUF_MAX_BIGNUM	(16384 / 8)	/* Max bignum *bytes* */
 #define SSHBUF_MAX_ECPOINT	((528 * 2 / 8) + 1) /* Max EC point *bytes* */
diff --git a/sshconnect.c b/sshconnect.c
index 78813c16..d0eb84cf 100644
--- a/sshconnect.c
+++ b/sshconnect.c
@@ -328,6 +328,31 @@ check_ifaddrs(const char *ifname, int af, const struct ifaddrs *ifaddrs,
 #endif
 
 /*
+ * Set TCP receive buffer if requested.
+ * Note: tuning needs to happen after the socket is
+ * created but before the connection happens
+ * so winscale is negotiated properly -cjr
+ */
+static void
+ssh_set_socket_recvbuf(int sock)
+{
+	void *buf = (void *)&options.tcp_rcv_buf;
+	int sz = sizeof(options.tcp_rcv_buf);
+	int socksize;
+	int socksizelen = sizeof(int);
+
+	debug("setsockopt Attempting to set SO_RCVBUF to %d", options.tcp_rcv_buf);
+	if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF, buf, sz) >= 0) {
+	  getsockopt(sock, SOL_SOCKET, SO_RCVBUF, &socksize, &socksizelen);
+	  debug("setsockopt SO_RCVBUF: %.100s %d", strerror(errno), socksize);
+	}
+	else
+		error("Couldn't set socket receive buffer to %d: %.100s",
+		    options.tcp_rcv_buf, strerror(errno));
+}
+
+
+/*
  * Creates a socket for use as the ssh connection.
  */
 static int
@@ -349,6 +374,9 @@ ssh_create_socket(struct addrinfo *ai)
 	}
 	fcntl(sock, F_SETFD, FD_CLOEXEC);
 
+	if (options.tcp_rcv_buf > 0)
+		ssh_set_socket_recvbuf(sock);
+
 	/* Bind the socket to an alternative local IP address */
 	if (options.bind_address == NULL && options.bind_interface == NULL)
 		return sock;
diff --git a/sshconnect2.c b/sshconnect2.c
index 10e4f0a0..c88fae68 100644
--- a/sshconnect2.c
+++ b/sshconnect2.c
@@ -83,6 +83,13 @@ extern char *server_version_string;
 extern Options options;
 
 /*
+ * tty_flag is set in ssh.c. Use this in ssh_userauth2:
+ * if it is set, then prevent the switch to the null cipher.
+ */
+
+extern int tty_flag;
+
+/*
  * SSH2 key exchange
  */
 
@@ -154,6 +161,8 @@ order_hostkeyalgs(char *host, struct sockaddr *hostaddr, u_short port)
 	return ret;
 }
 
+static char *myproposal[PROPOSAL_MAX];
+static const char *myproposal_default[PROPOSAL_MAX] = { KEX_CLIENT };
 void
 ssh_kex2(char *host, struct sockaddr *hostaddr, u_short port)
 {
@@ -162,6 +171,8 @@ ssh_kex2(char *host, struct sockaddr *hostaddr, u_short port)
 	struct kex *kex;
 	int r;
 
+	memcpy(&myproposal, &myproposal_default, sizeof(myproposal));
+
 	xxx_host = host;
 	xxx_hostaddr = hostaddr;
 
@@ -412,6 +423,47 @@ ssh_userauth2(const char *local_user, const char *server_user, char *host,
 
 	if (!authctxt.success)
 		fatal("Authentication failed.");
+
+	/*
+	 * If the user wants to use the none cipher, do it post authentication
+	 * and only if the right conditions are met -- both of the NONE commands
+	 * must be true and there must be no tty allocated.
+	 */
+	if ((options.none_switch == 1) && (options.none_enabled == 1)) {
+		if (!tty_flag) { /* no null on tty sessions */
+			debug("Requesting none rekeying...");
+			memcpy(&myproposal, &myproposal_default, sizeof(myproposal));
+			myproposal[PROPOSAL_ENC_ALGS_STOC] = "none";
+			myproposal[PROPOSAL_ENC_ALGS_CTOS] = "none";
+			kex_prop2buf(active_state->kex->my, myproposal);
+			packet_request_rekeying();
+			fprintf(stderr, "WARNING: ENABLED NONE CIPHER\n");
+		} else {
+			/* requested NONE cipher when in a tty */
+			debug("Cannot switch to NONE cipher with tty allocated");
+			fprintf(stderr, "NONE cipher switch disabled when a TTY is allocated\n");
+		}
+	}
+
+#ifdef WITH_OPENSSL
+	if (options.disable_multithreaded == 0) {
+		/* if we are using aes-ctr there can be issues in either a fork or sandbox
+		 * so the initial aes-ctr is defined to point to the original single process
+		 * evp. After authentication we'll be past the fork and the sandboxed privsep
+		 * so we repoint the define to the multithreaded evp. To start the threads we
+		 * then force a rekey
+		 */
+		const void *cc = ssh_packet_get_send_context(active_state);
+		
+		/* only do this for the ctr cipher. otherwise gcm mode breaks. Don't know why though */
+		if (strstr(cipher_ctx_name(cc), "ctr")) {
+			debug("Single to Multithread CTR cipher swap - client request");
+			cipher_reset_multithreaded();
+			packet_request_rekeying();
+		}
+	}
+#endif
+
 	debug("Authentication succeeded (%s).", authctxt.method->name);
 }
 
diff --git a/sshd.c b/sshd.c
index a738c3ab..edf04fff 100644
--- a/sshd.c
+++ b/sshd.c
@@ -373,7 +373,7 @@ sshd_exchange_identification(struct ssh *ssh, int sock_in, int sock_out)
 	char remote_version[256];	/* Must be at least as big as buf. */
 
 	xasprintf(&server_version_string, "SSH-%d.%d-%.100s%s%s\r\n",
-	    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_VERSION,
+	    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_RELEASE,
 	    *options.version_addendum == '\0' ? "" : " ",
 	    options.version_addendum);
 
@@ -428,6 +428,9 @@ sshd_exchange_identification(struct ssh *ssh, int sock_in, int sock_out)
 	}
 	debug("Client protocol version %d.%d; client software version %.100s",
 	    remote_major, remote_minor, remote_version);
+	logit("SSH: Server;Ltype: Version;Remote: %s-%d;Protocol: %d.%d;Client: %.100s",
+	      ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
+	    remote_major, remote_minor, remote_version);
 
 	ssh->compat = compat_datafellows(remote_version);
 
@@ -1037,6 +1040,8 @@ listen_on_addrs(struct listenaddr *la)
 	int ret, listen_sock;
 	struct addrinfo *ai;
 	char ntop[NI_MAXHOST], strport[NI_MAXSERV];
+	int socksize;
+	int socksizelen = sizeof(int);
 
 	for (ai = la->addrs; ai; ai = ai->ai_next) {
 		if (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)
@@ -1082,6 +1087,11 @@ listen_on_addrs(struct listenaddr *la)
 
 		debug("Bind to port %s on %s.", strport, ntop);
 
+		getsockopt(listen_sock, SOL_SOCKET, SO_RCVBUF,
+				   &socksize, &socksizelen);
+		debug("Server TCP RWIN socket size: %d", socksize);
+		debug("HPN Buffer Size: %d", options.hpn_buffer_size);
+
 		/* Bind the socket to the desired port. */
 		if (bind(listen_sock, ai->ai_addr, ai->ai_addrlen) < 0) {
 			error("Bind to port %s on %s failed: %.200s.",
@@ -1683,6 +1693,13 @@ main(int ac, char **av)
 	/* Fill in default values for those options not explicitly set. */
 	fill_default_server_options(&options);
 
+	if (options.none_enabled == 1) {
+		char *old_ciphers = options.ciphers;
+
+		xasprintf(&options.ciphers, "%s,none", old_ciphers);
+		free(old_ciphers);
+	}
+
 	/* challenge-response is implemented via keyboard interactive */
 	if (options.challenge_response_authentication)
 		options.kbd_interactive_authentication = 1;
@@ -2105,6 +2122,9 @@ main(int ac, char **av)
 	    rdomain == NULL ? "" : "\"");
 	free(laddr);
 
+	/* set the HPN options for the child */
+	channel_set_hpn(options.hpn_disabled, options.hpn_buffer_size);
+
 	/*
 	 * We don't want to listen forever unless the other side
 	 * successfully authenticates itself.  So we set up an alarm which is
@@ -2208,6 +2228,25 @@ main(int ac, char **av)
 	/* Try to send all our hostkeys to the client */
 	notify_hostkeys(ssh);
 
+#ifdef WITH_OPENSSL
+	if (options.disable_multithreaded == 0) {
+		/* if we are using aes-ctr there can be issues in either a fork or sandbox
+		 * so the initial aes-ctr is defined to point ot the original single process
+		 * evp. After authentication we'll be past the fork and the sandboxed privsep
+		 * so we repoint the define to the multithreaded evp. To start the threads we
+		 * then force a rekey
+		 */
+		const void *cc = ssh_packet_get_send_context(active_state);
+		
+		/* only rekey if necessary. If we don't do this gcm mode cipher breaks */
+		if (strstr(cipher_ctx_name(cc), "ctr")) {
+			debug("Single to Multithreaded CTR cipher swap - server request");
+			cipher_reset_multithreaded();
+			packet_request_rekeying();
+		}
+	}
+#endif
+
 	/* Start session. */
 	do_authenticated(ssh, authctxt);
 
@@ -2267,6 +2306,9 @@ do_ssh2_kex(void)
 	struct kex *kex;
 	int r;
 
+	if (options.none_enabled == 1)
+		debug("WARNING: None cipher enabled");
+
 	myproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(
 	    options.kex_algorithms);
 	myproposal[PROPOSAL_ENC_ALGS_CTOS] = compat_cipher_proposal(
diff --git a/sshd_config b/sshd_config
index 19b7c91a..64dcb9a6 100644
--- a/sshd_config
+++ b/sshd_config
@@ -108,6 +108,19 @@ AuthorizedKeysFile	.ssh/authorized_keys
 # override default of no subsystems
 Subsystem	sftp	/usr/libexec/sftp-server
 
+# the following are HPN related configuration options
+# tcp receive buffer polling. disable in non autotuning kernels
+#TcpRcvBufPoll yes
+
+# disable hpn performance boosts
+#HPNDisabled no
+
+# buffer size for hpn to non-hpn connections
+#HPNBufferSize 2048
+
+# allow the use of the none cipher
+#NoneEnabled no
+
 # Example of overriding settings on a per-user basis
 #Match User anoncvs
 #	X11Forwarding no
diff --git a/sshkey.c b/sshkey.c
index 72c08c7e..e289ba3b 100644
--- a/sshkey.c
+++ b/sshkey.c
@@ -292,10 +292,18 @@ sshkey_size(const struct sshkey *k)
 #ifdef WITH_OPENSSL
 	case KEY_RSA:
 	case KEY_RSA_CERT:
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		return RSA_bits(k->rsa);
+#else
 		return BN_num_bits(k->rsa->n);
+#endif
 	case KEY_DSA:
 	case KEY_DSA_CERT:
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		return DSA_bits(k->dsa);
+#else
 		return BN_num_bits(k->dsa->p);
+#endif
 	case KEY_ECDSA:
 	case KEY_ECDSA_CERT:
 		return sshkey_curve_nid_to_bits(k->ecdsa_nid);
@@ -500,6 +508,24 @@ sshkey_new(int type)
 #ifdef WITH_OPENSSL
 	case KEY_RSA:
 	case KEY_RSA_CERT:
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	        {
+		BIGNUM *n=NULL, *e=NULL; /* just allocate */
+		if ((rsa = RSA_new()) == NULL ||
+		    (n = BN_new()) == NULL ||
+		    (e = BN_new()) == NULL) {
+			BN_free(n);
+			BN_free(e);
+			RSA_free(rsa);
+			free(k);
+			return NULL;
+		}
+		BN_clear(n); BN_clear(e);
+		if (RSA_set0_key(rsa, n, e, NULL) == 0)
+			return NULL;
+		n = e = NULL;
+		}
+#else
 		if ((rsa = RSA_new()) == NULL ||
 		    (rsa->n = BN_new()) == NULL ||
 		    (rsa->e = BN_new()) == NULL) {
@@ -507,10 +533,40 @@ sshkey_new(int type)
 			free(k);
 			return NULL;
 		}
-		k->rsa = rsa;
+#endif
+	        k->rsa = rsa;
 		break;
 	case KEY_DSA:
 	case KEY_DSA_CERT:
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	        {
+		BIGNUM *p=NULL, *q=NULL, *g=NULL, *pubkey=NULL; /* just allocate */
+		if ((dsa = DSA_new()) == NULL ||
+		    (p = BN_new()) == NULL ||
+		    (q = BN_new()) == NULL ||
+		    (g = BN_new()) == NULL ||
+		    (pubkey = BN_new()) == NULL) {
+			BN_free(p);
+			BN_free(q);
+			BN_free(g);
+			BN_free(pubkey);
+			DSA_free(dsa);
+			free(k);
+			return NULL;
+		}
+		if (DSA_set0_pqg(dsa, p, q, g) == 0) {
+			BN_free(p); BN_free(q); BN_free(g);
+			BN_free(pubkey);
+			return NULL;
+		}
+		p = q = g = NULL;
+		if (DSA_set0_key(dsa, pubkey, NULL) == 0) {
+			BN_free(pubkey);
+			return NULL;
+		}
+		pubkey = NULL;
+		}
+#else
 		if ((dsa = DSA_new()) == NULL ||
 		    (dsa->p = BN_new()) == NULL ||
 		    (dsa->q = BN_new()) == NULL ||
@@ -520,6 +576,7 @@ sshkey_new(int type)
 			free(k);
 			return NULL;
 		}
+#endif
 		k->dsa = dsa;
 		break;
 	case KEY_ECDSA:
@@ -557,6 +614,51 @@ sshkey_add_private(struct sshkey *k)
 #ifdef WITH_OPENSSL
 	case KEY_RSA:
 	case KEY_RSA_CERT:
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		/* Allocate BIGNUM. This is a mess.
+		   For OpenSSL 1.1.x API these shouldn't be mandatory,
+		   but some regression tests for non-NULL pointer of
+		   the data. */
+#define new_or_dup(bn, nbn) \
+		if (bn == NULL) { \
+			if ((nbn = BN_new()) == NULL) \
+				return SSH_ERR_ALLOC_FAIL; \
+		} else { \
+			/* otherwise use-after-free will occur */ \
+			if ((nbn = BN_dup(bn)) == NULL) \
+				return SSH_ERR_ALLOC_FAIL; \
+		}
+		{
+		const BIGNUM *d, *iqmp, *q, *p, *dmq1, *dmp1; /* allocate if NULL */
+		BIGNUM *nd, *niqmp, *nq, *np, *ndmq1, *ndmp1;
+
+		RSA_get0_key(k->rsa, NULL, NULL, &d);
+		RSA_get0_factors(k->rsa, &p, &q);
+		RSA_get0_crt_params(k->rsa, &dmp1, &dmq1, &iqmp);
+
+		new_or_dup(d, nd);
+		new_or_dup(iqmp, niqmp);
+		new_or_dup(q, nq);
+		new_or_dup(p, np);
+		new_or_dup(dmq1, ndmq1);
+		new_or_dup(dmp1, ndmp1);
+
+		if (RSA_set0_key(k->rsa, NULL, NULL, nd) == 0)
+			goto error1;
+		nd = NULL;
+		if (RSA_set0_factors(k->rsa, np, nq) == 0)
+			goto error1;
+		np = nq = NULL;
+		if (RSA_set0_crt_params(k->rsa, ndmp1, ndmq1, niqmp) == 0) {
+error1:
+			BN_free(nd);
+			BN_free(np); BN_free(nq);
+			BN_free(ndmp1); BN_free(ndmq1); BN_free(niqmp);
+			return SSH_ERR_LIBCRYPTO_ERROR;
+		}
+		ndmp1 = ndmq1 = niqmp = NULL;
+		}
+#else
 #define bn_maybe_alloc_failed(p) (p == NULL && (p = BN_new()) == NULL)
 		if (bn_maybe_alloc_failed(k->rsa->d) ||
 		    bn_maybe_alloc_failed(k->rsa->iqmp) ||
@@ -565,13 +667,28 @@ sshkey_add_private(struct sshkey *k)
 		    bn_maybe_alloc_failed(k->rsa->dmq1) ||
 		    bn_maybe_alloc_failed(k->rsa->dmp1))
 			return SSH_ERR_ALLOC_FAIL;
+#endif
 		break;
 	case KEY_DSA:
 	case KEY_DSA_CERT:
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		{
+		const BIGNUM *priv_key;
+		BIGNUM *npriv_key;
+		DSA_get0_key(k->dsa, NULL, &priv_key);
+		new_or_dup(priv_key, npriv_key);
+		if (DSA_set0_key(k->dsa, NULL, npriv_key) == 0) {
+			BN_free(npriv_key);
+			return SSH_ERR_LIBCRYPTO_ERROR;
+		}
+		}
+#else
 		if (bn_maybe_alloc_failed(k->dsa->priv_key))
 			return SSH_ERR_ALLOC_FAIL;
+#endif
 		break;
 #undef bn_maybe_alloc_failed
+#undef new_or_dup
 	case KEY_ECDSA:
 	case KEY_ECDSA_CERT:
 		/* Cannot do anything until we know the group */
@@ -695,16 +812,48 @@ sshkey_equal_public(const struct sshkey *a, const struct sshkey *b)
 #ifdef WITH_OPENSSL
 	case KEY_RSA_CERT:
 	case KEY_RSA:
-		return a->rsa != NULL && b->rsa != NULL &&
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	{
+		const BIGNUM *a_e, *b_e, *a_n, *b_n;
+		const BIGNUM *a_d, *b_d;
+		if (a->rsa == NULL) return 0;
+		if (b->rsa == NULL) return 0;
+		RSA_get0_key(a->rsa, &a_n, &a_e, &a_d);
+		RSA_get0_key(b->rsa, &b_n, &b_e, &b_d);
+		return
+		    BN_cmp(a_e, b_e) == 0 &&
+		    BN_cmp(a_n, b_n) == 0;
+		}
+#else
+	        return a->rsa != NULL && b->rsa != NULL &&
 		    BN_cmp(a->rsa->e, b->rsa->e) == 0 &&
 		    BN_cmp(a->rsa->n, b->rsa->n) == 0;
+#endif
 	case KEY_DSA_CERT:
 	case KEY_DSA:
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	        {
+		const BIGNUM *a_p, *a_q, *a_g, *a_pub_key;
+		const BIGNUM *b_p, *b_q, *b_g, *b_pub_key;
+		if (a->dsa == NULL) return 0;
+		if (b->dsa == NULL) return 0;
+		DSA_get0_pqg(a->dsa, &a_p, &a_q, &a_g);
+		DSA_get0_pqg(b->dsa, &b_p, &b_q, &b_g);
+		DSA_get0_key(a->dsa, &a_pub_key, NULL);
+		DSA_get0_key(b->dsa, &b_pub_key, NULL);
+		return 
+		    BN_cmp(a_p, b_p) == 0 &&
+		    BN_cmp(a_q, b_q) == 0 &&
+		    BN_cmp(a_g, b_g) == 0 &&
+		    BN_cmp(a_pub_key, b_pub_key) == 0;
+		}
+#else
 		return a->dsa != NULL && b->dsa != NULL &&
-		    BN_cmp(a->dsa->p, b->dsa->p) == 0 &&
-		    BN_cmp(a->dsa->q, b->dsa->q) == 0 &&
-		    BN_cmp(a->dsa->g, b->dsa->g) == 0 &&
-		    BN_cmp(a->dsa->pub_key, b->dsa->pub_key) == 0;
+			BN_cmp(a->dsa->p, b->dsa->p) == 0 &&
+			BN_cmp(a->dsa->q, b->dsa->q) == 0 &&
+			BN_cmp(a->dsa->g, b->dsa->g) == 0 &&
+			BN_cmp(a->dsa->pub_key, b->dsa->pub_key) == 0;
+#endif
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA_CERT:
 	case KEY_ECDSA:
@@ -793,12 +942,26 @@ to_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain,
 	case KEY_DSA:
 		if (key->dsa == NULL)
 			return SSH_ERR_INVALID_ARGUMENT;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		{
+		const BIGNUM *p, *q, *g, *pub_key;
+		DSA_get0_pqg(key->dsa, &p, &q, &g);
+		DSA_get0_key(key->dsa, &pub_key, NULL);
+		if ((ret = sshbuf_put_cstring(b, typename)) != 0 ||
+		    (ret = sshbuf_put_bignum2(b, p)) != 0 ||
+		    (ret = sshbuf_put_bignum2(b, q)) != 0 ||
+		    (ret = sshbuf_put_bignum2(b, g)) != 0 ||
+		    (ret = sshbuf_put_bignum2(b, pub_key)) != 0)
+			return ret;
+		}
+#else
 		if ((ret = sshbuf_put_cstring(b, typename)) != 0 ||
 		    (ret = sshbuf_put_bignum2(b, key->dsa->p)) != 0 ||
 		    (ret = sshbuf_put_bignum2(b, key->dsa->q)) != 0 ||
 		    (ret = sshbuf_put_bignum2(b, key->dsa->g)) != 0 ||
 		    (ret = sshbuf_put_bignum2(b, key->dsa->pub_key)) != 0)
 			return ret;
+#endif
 		break;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
@@ -814,10 +977,21 @@ to_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain,
 	case KEY_RSA:
 		if (key->rsa == NULL)
 			return SSH_ERR_INVALID_ARGUMENT;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		{
+		const BIGNUM *e, *n;
+		RSA_get0_key(key->rsa, &n, &e, NULL);
+		if ((ret = sshbuf_put_cstring(b, typename)) != 0 ||
+		    (ret = sshbuf_put_bignum2(b, e)) != 0 ||
+		    (ret = sshbuf_put_bignum2(b, n)) != 0)
+			return ret;
+		}
+#else
 		if ((ret = sshbuf_put_cstring(b, typename)) != 0 ||
 		    (ret = sshbuf_put_bignum2(b, key->rsa->e)) != 0 ||
 		    (ret = sshbuf_put_bignum2(b, key->rsa->n)) != 0)
 			return ret;
+#endif
 		break;
 #endif /* WITH_OPENSSL */
 	case KEY_ED25519:
@@ -1758,6 +1932,37 @@ sshkey_from_private(const struct sshkey *k, struct sshkey **pkp)
 	case KEY_DSA_CERT:
 		if ((n = sshkey_new(k->type)) == NULL)
 			return SSH_ERR_ALLOC_FAIL;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		{
+		const BIGNUM *p, *q, *g, *pub_key, *priv_key;
+		BIGNUM *cp=NULL, *cq=NULL, *cg=NULL, *cpub_key=NULL;
+		DSA_get0_pqg(k->dsa, &p, &q, &g);
+		DSA_get0_key(k->dsa, &pub_key, &priv_key);
+		if ((cp = BN_dup(p)) == NULL ||
+		    (cq = BN_dup(q)) == NULL ||
+		    (cg = BN_dup(g)) == NULL ||
+		    (cpub_key = BN_dup(pub_key)) == NULL) {
+			BN_free(cp); BN_free(cq); BN_free(cg);
+			BN_free(cpub_key);
+			sshkey_free(n);
+			return SSH_ERR_ALLOC_FAIL;
+		}
+		if (DSA_set0_pqg(n->dsa, cp, cq, cg) == 0)
+			goto error1;
+		cp = cq = cg = NULL;
+		if (DSA_set0_key(n->dsa, cpub_key, NULL) == 0) {
+error1:
+			BN_free(cp); BN_free(cq); BN_free(cg);
+			BN_free(cpub_key);
+			sshkey_free(n);
+			return SSH_ERR_LIBCRYPTO_ERROR;
+		}
+		cpub_key = NULL;
+		}
+		break;
+#else
+		if ((n = sshkey_new(k->type)) == NULL)
+			return SSH_ERR_ALLOC_FAIL;
 		if ((BN_copy(n->dsa->p, k->dsa->p) == NULL) ||
 		    (BN_copy(n->dsa->q, k->dsa->q) == NULL) ||
 		    (BN_copy(n->dsa->g, k->dsa->g) == NULL) ||
@@ -1766,6 +1971,7 @@ sshkey_from_private(const struct sshkey *k, struct sshkey **pkp)
 			return SSH_ERR_ALLOC_FAIL;
 		}
 		break;
+#endif
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
 	case KEY_ECDSA_CERT:
@@ -1788,11 +1994,33 @@ sshkey_from_private(const struct sshkey *k, struct sshkey **pkp)
 	case KEY_RSA_CERT:
 		if ((n = sshkey_new(k->type)) == NULL)
 			return SSH_ERR_ALLOC_FAIL;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		{
+		const BIGNUM *nn, *e, *d;
+		BIGNUM *cn=NULL, *ce=NULL;
+		RSA_get0_key(k->rsa, &nn, &e, &d);
+		if ((cn = BN_dup(nn)) == NULL ||
+		    (ce = BN_dup(e)) == NULL ) {
+			BN_free(cn); BN_free(ce);
+			sshkey_free(n);
+			return SSH_ERR_ALLOC_FAIL;
+		}
+		if (RSA_set0_key(n->rsa, cn, ce, NULL) == 0) {
+			BN_free(cn); BN_free(ce);
+			sshkey_free(n);
+			return SSH_ERR_LIBCRYPTO_ERROR;
+		}
+		cn = ce = NULL;
+		}
+#else
+		if ((n = sshkey_new(k->type)) == NULL)
+			return SSH_ERR_ALLOC_FAIL;
 		if ((BN_copy(n->rsa->n, k->rsa->n) == NULL) ||
 		    (BN_copy(n->rsa->e, k->rsa->e) == NULL)) {
 			sshkey_free(n);
 			return SSH_ERR_ALLOC_FAIL;
 		}
+#endif
 		break;
 #endif /* WITH_OPENSSL */
 	case KEY_ED25519:
@@ -2013,6 +2241,32 @@ sshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,
 			ret = SSH_ERR_ALLOC_FAIL;
 			goto out;
 		}
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		{
+		BIGNUM *e=NULL, *n=NULL;
+		if ((e = BN_new()) == NULL ||
+		    (n = BN_new()) == NULL ) {
+			ret = SSH_ERR_ALLOC_FAIL;
+			BN_free(e); BN_free(n);
+			goto out;
+		}
+		if (sshbuf_get_bignum2(b, e) != 0 ||
+		    sshbuf_get_bignum2(b, n) != 0) {
+			ret = SSH_ERR_INVALID_FORMAT;
+			BN_free(e); BN_free(n);
+			goto out;
+		}
+		if (RSA_set0_key(key->rsa, n, e, NULL) == 0) {
+			BN_free(e); BN_free(n);
+			return SSH_ERR_LIBCRYPTO_ERROR;
+		}
+		n = e = NULL;
+		}
+		if (RSA_bits(key->rsa) < SSH_RSA_MINIMUM_MODULUS_SIZE) {
+			ret = SSH_ERR_KEY_LENGTH;
+			goto out;
+		}
+#else
 		if (sshbuf_get_bignum2(b, key->rsa->e) != 0 ||
 		    sshbuf_get_bignum2(b, key->rsa->n) != 0) {
 			ret = SSH_ERR_INVALID_FORMAT;
@@ -2022,6 +2276,7 @@ sshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,
 			ret = SSH_ERR_KEY_LENGTH;
 			goto out;
 		}
+#endif
 #ifdef DEBUG_PK
 		RSA_print_fp(stderr, key->rsa, 8);
 #endif
@@ -2038,6 +2293,38 @@ sshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,
 			ret = SSH_ERR_ALLOC_FAIL;
 			goto out;
 		}
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		{
+		BIGNUM *p=NULL, *q=NULL, *g=NULL, *pub_key=NULL;
+		if ((p = BN_new()) == NULL ||
+		    (q = BN_new()) == NULL ||
+		    (g = BN_new()) == NULL ||
+		    (pub_key = BN_new()) == NULL) {
+			ret = SSH_ERR_ALLOC_FAIL;
+			goto error1;
+		}
+		if (sshbuf_get_bignum2(b, p) != 0 ||
+		    sshbuf_get_bignum2(b, q) != 0 ||
+		    sshbuf_get_bignum2(b, g) != 0 ||
+		    sshbuf_get_bignum2(b, pub_key) != 0) {
+			ret = SSH_ERR_INVALID_FORMAT;
+			goto error1;
+		}
+		if (DSA_set0_pqg(key->dsa, p, q, g) == 0) {
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+			goto error1;
+		}
+		p = q = g = NULL;
+		if (DSA_set0_key(key->dsa, pub_key, NULL) == 0) {
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+error1:
+			BN_free(p); BN_free(q); BN_free(g);
+			BN_free(pub_key);
+			goto out;
+		}
+		        pub_key = NULL;
+		}
+#else
 		if (sshbuf_get_bignum2(b, key->dsa->p) != 0 ||
 		    sshbuf_get_bignum2(b, key->dsa->q) != 0 ||
 		    sshbuf_get_bignum2(b, key->dsa->g) != 0 ||
@@ -2045,6 +2332,7 @@ sshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,
 			ret = SSH_ERR_INVALID_FORMAT;
 			goto out;
 		}
+#endif
 #ifdef DEBUG_PK
 		DSA_print_fp(stderr, key->dsa, 8);
 #endif
@@ -2389,18 +2677,74 @@ sshkey_demote(const struct sshkey *k, struct sshkey **dkp)
 			goto fail;
 		/* FALLTHROUGH */
 	case KEY_RSA:
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		if ((pk->rsa = RSA_new()) == NULL ){
+			ret = SSH_ERR_ALLOC_FAIL;
+			goto fail;
+			}
+		{
+		const BIGNUM *ke, *kn;
+		BIGNUM *pke=NULL, *pkn=NULL;
+		RSA_get0_key(k->rsa, &kn, &ke, NULL);
+		 if ((pke = BN_dup(ke)) == NULL ||
+		     (pkn = BN_dup(kn)) == NULL) {
+			ret = SSH_ERR_ALLOC_FAIL;
+			BN_free(pke); BN_free(pkn);
+			goto fail;
+			}
+		if (RSA_set0_key(pk->rsa, pkn, pke, NULL) == 0) {
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+			BN_free(pke); BN_free(pkn);
+			goto fail;
+		}
+		pkn = pke = NULL;
+		}
+#else
 		if ((pk->rsa = RSA_new()) == NULL ||
 		    (pk->rsa->e = BN_dup(k->rsa->e)) == NULL ||
 		    (pk->rsa->n = BN_dup(k->rsa->n)) == NULL) {
 			ret = SSH_ERR_ALLOC_FAIL;
 			goto fail;
-			}
+		        }
+#endif
 		break;
 	case KEY_DSA_CERT:
 		if ((ret = sshkey_cert_copy(k, pk)) != 0)
 			goto fail;
 		/* FALLTHROUGH */
 	case KEY_DSA:
+		if ((pk->dsa = DSA_new()) == NULL ) {
+			ret = SSH_ERR_ALLOC_FAIL;
+			goto fail;
+		}
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		{
+		const BIGNUM *kp, *kq, *kg, *kpub_key;
+		BIGNUM *pkp=NULL, *pkq=NULL, *pkg=NULL, *pkpub_key=NULL;
+		DSA_get0_pqg(k->dsa, &kp, &kq, &kg);
+		DSA_get0_key(k->dsa, &kpub_key, NULL);
+		if ((pkp = BN_dup(kp)) == NULL ||
+		    (pkq = BN_dup(kq)) == NULL ||
+		    (pkg = BN_dup(kg)) == NULL ||
+		    (pkpub_key = BN_dup(kpub_key)) == NULL) {
+			ret = SSH_ERR_ALLOC_FAIL;
+			goto error1;
+		}
+		if (DSA_set0_pqg(pk->dsa, pkp, pkq, pkg) == 0) {
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+			goto error1;
+		}
+		pkp = pkq = pkg = NULL;
+		if (DSA_set0_key(pk->dsa, pkpub_key, NULL) == 0) {
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+error1:
+			BN_free(pkp); BN_free(pkq); BN_free(pkg);
+			BN_free(pkpub_key);
+			goto fail;
+		}
+		pkpub_key = NULL;
+		}
+#else
 		if ((pk->dsa = DSA_new()) == NULL ||
 		    (pk->dsa->p = BN_dup(k->dsa->p)) == NULL ||
 		    (pk->dsa->q = BN_dup(k->dsa->q)) == NULL ||
@@ -2409,6 +2753,7 @@ sshkey_demote(const struct sshkey *k, struct sshkey **dkp)
 			ret = SSH_ERR_ALLOC_FAIL;
 			goto fail;
 		}
+#endif
 		break;
 	case KEY_ECDSA_CERT:
 		if ((ret = sshkey_cert_copy(k, pk)) != 0)
@@ -2558,12 +2903,26 @@ sshkey_certify_custom(struct sshkey *k, struct sshkey *ca, const char *alg,
 	switch (k->type) {
 #ifdef WITH_OPENSSL
 	case KEY_DSA_CERT:
-		if ((ret = sshbuf_put_bignum2(cert, k->dsa->p)) != 0 ||
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	        {
+		const BIGNUM *p, *q, *g, *pub_key;
+		DSA_get0_pqg(k->dsa, &p, &q, &g);
+		DSA_get0_key(k->dsa, &pub_key, NULL);
+		if ((ret = sshbuf_put_bignum2(cert, p)) != 0 ||
+		    (ret = sshbuf_put_bignum2(cert, q)) != 0 ||
+		    (ret = sshbuf_put_bignum2(cert, g)) != 0 ||
+		    (ret = sshbuf_put_bignum2(cert, pub_key)) != 0) {
+			goto out;
+		}
+	        }
+#else
+                if ((ret = sshbuf_put_bignum2(cert, k->dsa->p)) != 0 ||
 		    (ret = sshbuf_put_bignum2(cert, k->dsa->q)) != 0 ||
 		    (ret = sshbuf_put_bignum2(cert, k->dsa->g)) != 0 ||
 		    (ret = sshbuf_put_bignum2(cert, k->dsa->pub_key)) != 0)
 			goto out;
-		break;
+#endif
+	       break;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA_CERT:
 		if ((ret = sshbuf_put_cstring(cert,
@@ -2575,9 +2934,21 @@ sshkey_certify_custom(struct sshkey *k, struct sshkey *ca, const char *alg,
 		break;
 # endif /* OPENSSL_HAS_ECC */
 	case KEY_RSA_CERT:
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	        {
+		const BIGNUM *e, *n;
+		RSA_get0_key(k->rsa, &n, &e, NULL);
+		if (n == NULL || e == NULL ||
+		    (ret = sshbuf_put_bignum2(cert, e)) != 0 ||
+		    (ret = sshbuf_put_bignum2(cert, n)) != 0) {
+			goto out;
+		}
+		}
+#else
 		if ((ret = sshbuf_put_bignum2(cert, k->rsa->e)) != 0 ||
 		    (ret = sshbuf_put_bignum2(cert, k->rsa->n)) != 0)
 			goto out;
+#endif
 		break;
 #endif /* WITH_OPENSSL */
 	case KEY_ED25519_CERT:
@@ -2764,6 +3135,22 @@ sshkey_private_serialize_opt(const struct sshkey *key, struct sshbuf *b,
 	switch (key->type) {
 #ifdef WITH_OPENSSL
 	case KEY_RSA:
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	        {
+		const BIGNUM *n, *e, *d, *iqmp, *p, *q;
+		RSA_get0_key(key->rsa, &n, &e, &d);
+		RSA_get0_crt_params(key->rsa, NULL, NULL, &iqmp);
+		RSA_get0_factors(key->rsa, &p, &q);
+		if ((r = sshbuf_put_bignum2(b, n)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, e)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, d)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, iqmp)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, p)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, q)) != 0) {
+			goto out;
+		}
+		}
+#else
 		if ((r = sshbuf_put_bignum2(b, key->rsa->n)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, key->rsa->e)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, key->rsa->d)) != 0 ||
@@ -2771,35 +3158,78 @@ sshkey_private_serialize_opt(const struct sshkey *key, struct sshbuf *b,
 		    (r = sshbuf_put_bignum2(b, key->rsa->p)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, key->rsa->q)) != 0)
 			goto out;
+#endif
 		break;
 	case KEY_RSA_CERT:
 		if (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {
 			r = SSH_ERR_INVALID_ARGUMENT;
 			goto out;
 		}
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		{
+		const BIGNUM *d, *iqmp, *p, *q;
+		RSA_get0_key(key->rsa, NULL, NULL, &d);
+		RSA_get0_crt_params(key->rsa, NULL, NULL, &iqmp);
+		RSA_get0_factors(key->rsa, &p, &q);
+		if ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, d)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, iqmp)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, p)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, q)) != 0) {
+			goto out;
+		}
+		}
+#else
 		if ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, key->rsa->d)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, key->rsa->iqmp)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, key->rsa->p)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, key->rsa->q)) != 0)
 			goto out;
+#endif
 		break;
 	case KEY_DSA:
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	        {
+		const BIGNUM *p, *q, *g, *pub_key, *priv_key;
+		DSA_get0_pqg(key->dsa, &p, &q, &g);
+		DSA_get0_key(key->dsa, &pub_key, &priv_key);
+		if ((r = sshbuf_put_bignum2(b, p)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, q)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, g)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, pub_key)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, priv_key)) != 0) {
+			goto out;
+		}
+		}
+#else
 		if ((r = sshbuf_put_bignum2(b, key->dsa->p)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, key->dsa->q)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, key->dsa->g)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, key->dsa->pub_key)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, key->dsa->priv_key)) != 0)
 			goto out;
+#endif
 		break;
 	case KEY_DSA_CERT:
 		if (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {
 			r = SSH_ERR_INVALID_ARGUMENT;
 			goto out;
 		}
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		{
+		const BIGNUM *priv_key;
+		DSA_get0_key(key->dsa, NULL, &priv_key);
+		if ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, priv_key)) != 0) {
+			goto out;
+		}
+		}
+#else
 		if ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, key->dsa->priv_key)) != 0)
 			goto out;
+#endif
 		break;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
@@ -2913,18 +3343,77 @@ sshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)
 			r = SSH_ERR_ALLOC_FAIL;
 			goto out;
 		}
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		{
+		BIGNUM *p=NULL, *q=NULL, *g=NULL, *pub_key=NULL, *priv_key=NULL;
+		if ((p = BN_new()) == NULL ||
+		    (q = BN_new()) == NULL ||
+		    (g = BN_new()) == NULL ||
+		    (pub_key = BN_new()) == NULL ||
+		    (priv_key = BN_new()) == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto error1;
+		}
+		if (p == NULL || q == NULL || g == NULL ||
+		    pub_key == NULL || priv_key == NULL ||
+		    (r = sshbuf_get_bignum2(buf, p)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, q)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, g)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, pub_key)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, priv_key)) != 0) {
+			goto error1;
+		}
+		if (DSA_set0_pqg(k->dsa, p, q, g) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto error1;
+		}
+		p = q = g = NULL;
+		if (DSA_set0_key(k->dsa, pub_key, priv_key) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+error1:
+			BN_free(p); BN_free(q); BN_free(g);
+			BN_free(pub_key); BN_free(priv_key);
+			goto out;
+		}
+		pub_key = priv_key = NULL;
+		}
+#else
 		if ((r = sshbuf_get_bignum2(buf, k->dsa->p)) != 0 ||
 		    (r = sshbuf_get_bignum2(buf, k->dsa->q)) != 0 ||
 		    (r = sshbuf_get_bignum2(buf, k->dsa->g)) != 0 ||
 		    (r = sshbuf_get_bignum2(buf, k->dsa->pub_key)) != 0 ||
 		    (r = sshbuf_get_bignum2(buf, k->dsa->priv_key)) != 0)
 			goto out;
+#endif
 		break;
 	case KEY_DSA_CERT:
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+	        {
+		BIGNUM *priv_key=NULL;
+		if ((priv_key = BN_new()) == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		if (priv_key == NULL ||
+		    (r = sshkey_froms(buf, &k)) != 0 ||
+		    (r = sshkey_add_private(k)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, priv_key)) != 0) {
+			BN_free(priv_key);
+			goto out;
+		}
+		if (DSA_set0_key(k->dsa, NULL, priv_key) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			BN_free(priv_key);
+			goto out;
+		}
+		priv_key = NULL;
+		}
+#else
 		if ((r = sshkey_froms(buf, &k)) != 0 ||
 		    (r = sshkey_add_private(k)) != 0 ||
 		    (r = sshbuf_get_bignum2(buf, k->dsa->priv_key)) != 0)
 			goto out;
+#endif
 		break;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
@@ -2983,7 +3472,61 @@ sshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)
 			r = SSH_ERR_ALLOC_FAIL;
 			goto out;
 		}
-		if ((r = sshbuf_get_bignum2(buf, k->rsa->n)) != 0 ||
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		{
+		BIGNUM *n=NULL, *e=NULL, *d=NULL, *iqmp=NULL, *p=NULL, *q=NULL;
+		BIGNUM *dmp1=NULL, *dmq1=NULL; /* dummy for RSA_set0_crt_params */
+		if ((n = BN_new()) == NULL ||
+		    (e = BN_new()) == NULL ||
+		    (d = BN_new()) == NULL ||
+		    (iqmp = BN_new()) == NULL ||
+		    (p = BN_new()) == NULL ||
+		    (q = BN_new()) == NULL ||
+		    (dmp1 = BN_new()) == NULL ||
+		    (dmq1 = BN_new()) == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto error2;
+		}
+		BN_clear(dmp1); BN_clear(dmq1);
+		if ((r = sshbuf_get_bignum2(buf, n)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, e)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, d)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, iqmp)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, p)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, q)) != 0) {
+			goto error2;
+		}
+		if (RSA_set0_key(k->rsa, n, e, d) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto error2;
+		}
+		n = e = d = NULL;
+		/* dmp1,dmpq1 should be non NULL to set iqmp value */
+		if (RSA_set0_crt_params(k->rsa, dmp1, dmq1, iqmp) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto error2;
+		}
+		dmp1 = dmq1 = iqmp = NULL;
+		if (RSA_set0_factors(k->rsa, p, q) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+ error2:
+			BN_free(n); BN_free(e); BN_free(d);
+			BN_free(iqmp);
+			BN_free(p); BN_free(q);
+			BN_free(dmp1); BN_free(dmq1);
+			goto out;
+		}
+		p = q = NULL;
+		if ((r = ssh_rsa_generate_additional_parameters(k)) != 0) {
+			goto out;
+		}
+		}
+		if (RSA_bits(k->rsa) < SSH_RSA_MINIMUM_MODULUS_SIZE) {
+			r = SSH_ERR_KEY_LENGTH;
+			goto out;
+		}
+#else
+                if ((r = sshbuf_get_bignum2(buf, k->rsa->n)) != 0 ||
 		    (r = sshbuf_get_bignum2(buf, k->rsa->e)) != 0 ||
 		    (r = sshbuf_get_bignum2(buf, k->rsa->d)) != 0 ||
 		    (r = sshbuf_get_bignum2(buf, k->rsa->iqmp)) != 0 ||
@@ -2995,8 +3538,58 @@ sshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)
 			r = SSH_ERR_KEY_LENGTH;
 			goto out;
 		}
+#endif
 		break;
 	case KEY_RSA_CERT:
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		{
+		BIGNUM *d=NULL, *iqmp=NULL, *p=NULL, *q=NULL;
+		BIGNUM *dmp1=NULL, *dmq1=NULL; /* dummy for RSA_set0_crt_params */
+		if ((d = BN_new()) == NULL ||
+		    (iqmp = BN_new()) == NULL ||
+		    (p = BN_new()) == NULL ||
+		    (q = BN_new()) == NULL ||
+		    (dmp1 = BN_new()) == NULL ||
+		    (dmq1 = BN_new()) == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto error3;
+		}
+		BN_clear(dmp1); BN_clear(dmq1);
+		if ((r = sshkey_froms(buf, &k)) != 0 ||
+		    (r = sshkey_add_private(k)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, d)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, iqmp)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, p)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, q)) != 0) {
+			goto error3;
+		}
+		if (RSA_set0_key(k->rsa, NULL, NULL, d) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto error3;
+		}
+		/* dmp1,dmpq1 should be non NULL to set value */
+		if (RSA_set0_crt_params(k->rsa, dmp1, dmq1, iqmp) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto error3;
+		}
+		dmp1 = dmq1 = iqmp = NULL;
+		if (RSA_set0_factors(k->rsa, p, q) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+ error3:
+			BN_free(d); BN_free(iqmp);
+			BN_free(p); BN_free(q);
+			BN_free(dmp1); BN_free(dmq1);
+			goto out;
+		}
+		p = q = NULL;
+		if ((r = ssh_rsa_generate_additional_parameters(k)) != 0)
+			goto out;
+		}
+		if (RSA_bits(k->rsa) < SSH_RSA_MINIMUM_MODULUS_SIZE) {
+			r = SSH_ERR_KEY_LENGTH;
+			goto out;
+		}
+#else
 		if ((r = sshkey_froms(buf, &k)) != 0 ||
 		    (r = sshkey_add_private(k)) != 0 ||
 		    (r = sshbuf_get_bignum2(buf, k->rsa->d)) != 0 ||
@@ -3009,6 +3602,7 @@ sshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)
 			r = SSH_ERR_KEY_LENGTH;
 			goto out;
 		}
+#endif
 		break;
 #endif /* WITH_OPENSSL */
 	case KEY_ED25519:
@@ -3769,7 +4363,6 @@ translate_libcrypto_error(unsigned long pem_err)
 		switch (pem_reason) {
 		case EVP_R_BAD_DECRYPT:
 			return SSH_ERR_KEY_WRONG_PASSPHRASE;
-		case EVP_R_BN_DECODE_ERROR:
 		case EVP_R_DECODE_ERROR:
 #ifdef EVP_R_PRIVATE_KEY_DECODE_ERROR
 		case EVP_R_PRIVATE_KEY_DECODE_ERROR:
@@ -3834,7 +4427,7 @@ sshkey_parse_private_pem_fileblob(struct sshbuf *blob, int type,
 		r = convert_libcrypto_error();
 		goto out;
 	}
-	if (pk->type == EVP_PKEY_RSA &&
+	if (EVP_PKEY_id(pk) == EVP_PKEY_RSA &&
 	    (type == KEY_UNSPEC || type == KEY_RSA)) {
 		if ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {
 			r = SSH_ERR_ALLOC_FAIL;
@@ -3849,11 +4442,15 @@ sshkey_parse_private_pem_fileblob(struct sshbuf *blob, int type,
 			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
+#if OPENSSL_VERSION_NUMBER >= 0x10100000UL
+		if (RSA_bits(prv->rsa) < SSH_RSA_MINIMUM_MODULUS_SIZE) {
+#else
 		if (BN_num_bits(prv->rsa->n) < SSH_RSA_MINIMUM_MODULUS_SIZE) {
+#endif
 			r = SSH_ERR_KEY_LENGTH;
 			goto out;
 		}
-	} else if (pk->type == EVP_PKEY_DSA &&
+	} else if (EVP_PKEY_id(pk) == EVP_PKEY_DSA &&
 	    (type == KEY_UNSPEC || type == KEY_DSA)) {
 		if ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {
 			r = SSH_ERR_ALLOC_FAIL;
@@ -3865,7 +4462,7 @@ sshkey_parse_private_pem_fileblob(struct sshbuf *blob, int type,
 		DSA_print_fp(stderr, prv->dsa, 8);
 #endif
 #ifdef OPENSSL_HAS_ECC
-	} else if (pk->type == EVP_PKEY_EC &&
+	} else if (EVP_PKEY_id(pk) == EVP_PKEY_EC &&
 	    (type == KEY_UNSPEC || type == KEY_ECDSA)) {
 		if ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {
 			r = SSH_ERR_ALLOC_FAIL;
diff --git a/version.h b/version.h
index f1bbf00f..357245da 100644
--- a/version.h
+++ b/version.h
@@ -3,4 +3,5 @@
 #define SSH_VERSION	"OpenSSH_7.8"
 
 #define SSH_PORTABLE	"p1"
-#define SSH_RELEASE	SSH_VERSION SSH_PORTABLE
+#define SSH_HPN         "-hpn14v15"
+#define SSH_RELEASE	SSH_VERSION SSH_PORTABLE SSH_HPN
