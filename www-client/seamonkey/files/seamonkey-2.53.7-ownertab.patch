--- seamonkey-2.53.7/comm/suite/app/profile/suite-prefs.js
+++ seamonkey-2.53.7/comm/suite/app/profile/suite-prefs.js
@@ -225,16 +225,17 @@ pref("browser.tabs.autoHide", false);
 pref("browser.tabs.forceHide", false);
 pref("browser.tabs.closeWindowWithLastTab", true);
 pref("browser.tabs.warnOnClose", true);
 pref("browser.tabs.warnOnCloseOther", true);
 pref("browser.tabs.warnOnOpen", true);
 pref("browser.tabs.maxOpenBeforeWarn", 15);
 pref("browser.tabs.insertRelatedAfterCurrent", true);
 pref("browser.tabs.insertAllTabsAfterCurrent", false);
+pref("browser.tabs.selectOwnerOnClose", true);
 
 // For future use
 pref("browser.tabs.loadBookmarksInBackground", false);
 
 // how many browsers can be saved in the DOM (by the tabbed browser)
 pref("browser.tabs.max_tabs_undo", 3);
 // should popups by saved in the DOM (by the tabbed browser)
 pref("browser.tabs.cache_popups", false);
--- seamonkey-2.53.7/comm/suite/browser/tabbrowser.xml
+++ seamonkey-2.53.7/comm/suite/browser/tabbrowser.xml
@@ -1445,16 +1445,19 @@
                 opener: null,
               };
             }
 
             params.focusNewTab = params.inBackground != null ?
                 !params.inBackground :
                 !Services.prefs.getBoolPref("browser.tabs.loadInBackground");
 
+            if (params.focusNewTab)
+              params.ownerTab = this.selectedTab;
+
             return this.addTab(aURI, params);
          ]]>
         </body>
       </method>
 
       <method name="loadTabs">
         <parameter name="aURIs"/>
         <parameter name="aLoadInBackground"/>
@@ -1556,32 +1559,34 @@
         <parameter name="aPostData"/>
         <parameter name="aFocusNewTab"/>
         <parameter name="aAllowThirdPartyFixup"/>
         <body>
           <![CDATA[
             var aTriggeringPrincipal;
             var aReferrerPolicy;
             var aFromExternal;
+            var aOwner;
             var aRelatedToCurrent;
             var aAllowMixedContent;
             var aNoReferrer;
             var aUserContextId;
             var aOriginPrincipal;
             var aOpener;
             if (arguments.length == 2 &&
                 arguments[1] != null &&
                 typeof arguments[1] == "object" &&
                 !(arguments[1] instanceof Ci.nsIURI)) {
               let params = arguments[1];
               aTriggeringPrincipal  = params.triggeringPrincipal;
               aReferrerURI          = params.referrerURI;
               aReferrerPolicy       = params.referrerPolicy;
               aCharset              = params.charset;
               aPostData             = params.postData;
+              aOwner                = params.ownerTab;
               aFocusNewTab          = params.focusNewTab;
               aAllowThirdPartyFixup = params.allowThirdPartyFixup;
               aFromExternal         = params.fromExternal;
               aRelatedToCurrent     = params.relatedToCurrent;
               aAllowMixedContent    = params.allowMixedContent;
               aNoReferrer           = params.noReferrer;
               aUserContextId        = params.userContextId;
               aOriginPrincipal      = params.originPrincipal;
@@ -1640,16 +1645,19 @@
 
             // We start our browsers out as inactive.
             b.docShellIsActive = false;
 
             this.mStrip.collapsed = false;
 
             Services.prefs.setBoolPref("browser.tabs.forceHide", false);
 
+            // If this new tab is owned by another, assert that relationship
+            t.owner = aOwner ? aOwner : this.selectedTab;
+
             // wire up a progress listener for the new browser object.
             var position = this.tabs.length - 1;
             var tabListener = this.mTabProgressListener(t, b, blank);
             const filter = Cc["@mozilla.org/appshell/component/browser-status-filter;1"]
                              .createInstance(Ci.nsIWebProgress);
             filter.addProgressListener(tabListener, Ci.nsIWebProgress.NOTIFY_ALL);
             b.webProgress.addProgressListener(filter, Ci.nsIWebProgress.NOTIFY_ALL);
             this.mTabListeners[position] = tabListener;
@@ -2007,16 +2015,23 @@
             oldBrowser.webProgress.removeProgressListener(filter);
             filter.removeProgressListener(this.mTabListeners[index]);
             this.mTabFilters.splice(index, 1);
             this.mTabListeners.splice(index, 1);
 
             // We are no longer the primary content area
             oldBrowser.removeAttribute("primary");
 
+            // Remove this tab as the owner of any other tabs, since it's going away.
+            for (let tab of this.tabs) {
+              if ("owner" in tab && tab.owner == aTab)
+                // |tab| is a child of the tab we're removing, make it an orphan
+                tab.owner = null;
+            }
+
             // Now select the new tab before nuking the old one.
             var currentIndex = this.tabContainer.selectedIndex;
 
             var newIndex = -1;
             if (currentIndex > index)
               newIndex = currentIndex - 1;
             else if (currentIndex < index)
               newIndex = currentIndex;
@@ -2033,17 +2048,21 @@
             this._browsers = null;
 
             // Clean up before/afterselected attributes before removing the tab
             aTab._selected = false;
             aTab.remove();
 
             // When the current tab is removed select a new tab
             // and fire select events on tabpanels and tabs
-            if (this.mPreviousTab && (aTab == this.mCurrentTab))
+            if (aTab.owner && !aTab.owner.hidden && !aTab.owner.closing &&
+                Services.prefs.getBoolPref("browser.tabs.selectOwnerOnClose")) {
+              this.selectedTab = aTab.owner;
+            }
+            else if (this.mPreviousTab && (aTab == this.mCurrentTab))
               this.selectedTab = this.mPreviousTab;
             else {
               this.tabContainer.selectedIndex = newIndex;
 
               // We need to explicitly clear this, because updateCurrentBrowser
               // doesn't get called for a background tab
               this.mPreviousTab = null;
             }
