#
#  Hackish enough work-around to solve "zero-timeout/zero-poll" race issue.
#
#  When the race is in effect, it seems that "pendingEvents" is true, which
#  causes the timeout to be zeroed (ie. "no wait").
#
#  To avoid repeatable loop with "poll(..., ..., 0) = 0", we determine such
#  a situation and use increased non-zero timeout instead.
#
#  If such a work-around timeout (wa_timeout) appears bigger than the "normal"
#  PollTimeout(ts), use PollTimeout(ts) instead.
#
#  When poll() returns something non-zero, everithing is reset to normal behaviour.
#  
#

--- mozilla/netwerk/base/nsSocketTransportService2.cpp	2021-02-02 03:17:03.301412550 +0300
+++ mozilla/netwerk/base/nsSocketTransportService2.cpp-OK	2021-02-04 01:41:01.910951183 +0300
@@ -522,43 +522,75 @@ int32_t
 nsSocketTransportService::Poll(TimeDuration *pollDuration,
                                PRIntervalTime ts)
 {
     PRPollDesc *pollList;
     uint32_t pollCount;
     PRIntervalTime pollTimeout;
     *pollDuration = 0;
 
+    static bool was_zero_poll = false;
+    static bool was_pending_events = false;
+    static uint32_t wa_timeout = 0;
+#define WA_TIMEOUT_START    4
+#define WA_TIMEOUT_END      256
+
     // If there are pending events for this thread then
     // DoPollIteration() should service the network without blocking.
     bool pendingEvents = false;
     mRawThread->HasPendingEvents(&pendingEvents);
 
     if (mPollList[0].fd) {
         mPollList[0].out_flags = 0;
         pollList = mPollList;
         pollCount = mActiveCount + 1;
-        pollTimeout = pendingEvents ? PR_INTERVAL_NO_WAIT : PollTimeout(ts);
+        pollTimeout = PollTimeout(ts);
     }
     else {
         // no pollable event, so busy wait...
         pollCount = mActiveCount;
         if (pollCount)
             pollList = &mPollList[1];
         else
             pollList = nullptr;
-        pollTimeout =
-            pendingEvents ? PR_INTERVAL_NO_WAIT : PR_MillisecondsToInterval(25);
+        pollTimeout = PR_MillisecondsToInterval(25);
+    }
+
+    if (pendingEvents) {
+
+        if (was_zero_poll && was_pending_events) {
+            PRIntervalTime new_timeout;
+
+            if (!wa_timeout)
+                wa_timeout = WA_TIMEOUT_START;
+            else if (wa_timeout < WA_TIMEOUT_END)
+                wa_timeout <<= 1;
+            else
+                wa_timeout = WA_TIMEOUT_END;   //  paranoia...
+            new_timeout = PR_MillisecondsToInterval(wa_timeout);
+            if (pollTimeout > new_timeout)
+                pollTimeout = new_timeout;
+        }
+        else
+            pollTimeout = PR_INTERVAL_NO_WAIT;
     }
 
     SOCKET_LOG(("    timeout = %i milliseconds\n",
          PR_IntervalToMilliseconds(pollTimeout)));
 
     int32_t rv = PR_Poll(pollList, pollCount, pollTimeout);
 
+    if (rv == 0)
+        was_zero_poll = true;
+    else {
+        was_zero_poll = false;
+        wa_timeout = 0;
+    }
+    was_pending_events = pendingEvents;
+
     SOCKET_LOG(("    ...returned after %i milliseconds\n",
          PR_IntervalToMilliseconds(PR_IntervalNow() - ts)));
 
     return rv;
 }
 
 //-----------------------------------------------------------------------------
 // xpcom api
