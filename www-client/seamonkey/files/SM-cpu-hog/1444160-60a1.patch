# HG changeset patch
# User Honza Bambas <honzab.moz@firemni.cz>
# Date 1520830800 -7200
# Node ID ba1480b57708e536bdfc084ab0db64a55f870d15
# Parent  5c3b3a2359f8b91dac45ded252636136a99f2c6c
Bug 1444160 - Fix calculation of network socket timeout logic. r=valentin, mayhemer

diff --git a/netwerk/base/nsSocketTransportService2.cpp b/netwerk/base/nsSocketTransportService2.cpp
--- a/netwerk/base/nsSocketTransportService2.cpp
+++ b/netwerk/base/nsSocketTransportService2.cpp
@@ -60,16 +60,52 @@ PRCallOnceType nsSocketTransportService:
 // Utility functions
 bool
 OnSocketThread()
 {
   return PR_GetCurrentThread() == gSocketThread;
 }
 
 //-----------------------------------------------------------------------------
+
+bool
+nsSocketTransportService::SocketContext::IsTimedOut(PRIntervalTime now) const
+{
+    return TimeoutIn(now) == 0;
+}
+
+void
+nsSocketTransportService::SocketContext::StartTimeout()
+{
+    mPollStartEpoch = PR_IntervalNow();
+}
+
+void
+nsSocketTransportService::SocketContext::StopTimeout()
+{
+    mPollStartEpoch = 0;
+}
+
+PRIntervalTime
+nsSocketTransportService::SocketContext::TimeoutIn(PRIntervalTime now) const
+{
+    if (mHandler->mPollTimeout == UINT16_MAX || !mPollStartEpoch) {
+        return NS_SOCKET_POLL_TIMEOUT;
+    }
+
+    PRIntervalTime elapsed = (now - mPollStartEpoch);
+    PRIntervalTime timeout = PR_SecondsToInterval(mHandler->mPollTimeout);
+
+    if (elapsed >= timeout) {
+        return 0;
+    }
+    return timeout - elapsed;
+}
+
+//-----------------------------------------------------------------------------
 // ctor/dtor (called on the main/UI thread by the service manager)
 
 nsSocketTransportService::nsSocketTransportService()
     : mThread(nullptr)
     , mLock("nsSocketTransportService::mLock")
     , mInitialized(false)
     , mShuttingDown(false)
     , mOffline(false)
@@ -216,17 +252,17 @@ nsSocketTransportService::AttachSocket(P
 
     if (!CanAttachSocket()) {
         return NS_ERROR_NOT_AVAILABLE;
     }
 
     SocketContext sock;
     sock.mFD = fd;
     sock.mHandler = handler;
-    sock.mElapsedTime = 0;
+    sock.mPollStartEpoch = 0;
 
     nsresult rv = AddToIdleList(&sock);
     if (NS_SUCCEEDED(rv))
         NS_ADDREF(handler);
     return rv;
 }
 
 // the number of sockets that can be attached at any given time is
@@ -309,16 +345,18 @@ nsSocketTransportService::AddToPollList(
     uint32_t newSocketIndex = mActiveCount;
     if (ChaosMode::isActive(ChaosFeature::NetworkScheduling)) {
       newSocketIndex = ChaosMode::randomUint32LessThan(mActiveCount + 1);
       PodMove(mActiveList + newSocketIndex + 1, mActiveList + newSocketIndex,
               mActiveCount - newSocketIndex);
       PodMove(mPollList + newSocketIndex + 2, mPollList + newSocketIndex + 1,
               mActiveCount - newSocketIndex);
     }
+
+    sock->StartTimeout();
     mActiveList[newSocketIndex] = *sock;
     mActiveCount++;
 
     mPollList[newSocketIndex + 1].fd = sock->mFD;
     mPollList[newSocketIndex + 1].in_flags = sock->mHandler->mPollFlags;
     mPollList[newSocketIndex + 1].out_flags = 0;
 
     SOCKET_LOG(("  active=%u idle=%u\n", mActiveCount, mIdleCount));
@@ -433,85 +471,80 @@ nsSocketTransportService::GrowIdleList()
 
     mIdleListSize += toAdd;
     mIdleList = (SocketContext *)
         moz_xrealloc(mIdleList, sizeof(SocketContext) * mIdleListSize);
     return true;
 }
 
 PRIntervalTime
-nsSocketTransportService::PollTimeout()
+nsSocketTransportService::PollTimeout(PRIntervalTime now)
 {
-    if (mActiveCount == 0)
+    if (mActiveCount == 0) {
         return NS_SOCKET_POLL_TIMEOUT;
+    }
 
     // compute minimum time before any socket timeout expires.
-    uint32_t minR = UINT16_MAX;
+    PRIntervalTime minR = NS_SOCKET_POLL_TIMEOUT;
     for (uint32_t i=0; i<mActiveCount; ++i) {
         const SocketContext &s = mActiveList[i];
-        // mPollTimeout could be less than mElapsedTime if setTimeout
-        // was called with a value smaller than mElapsedTime.
-        uint32_t r = (s.mElapsedTime < s.mHandler->mPollTimeout)
-          ? s.mHandler->mPollTimeout - s.mElapsedTime
-          : 0;
-        if (r < minR)
+        PRIntervalTime r = s.TimeoutIn(now);
+        if (r < minR) {
             minR = r;
+        }
     }
-    // nsASocketHandler defines UINT16_MAX as do not timeout
-    if (minR == UINT16_MAX) {
+    if (minR == NS_SOCKET_POLL_TIMEOUT) {
         SOCKET_LOG(("poll timeout: none\n"));
         return NS_SOCKET_POLL_TIMEOUT;
     }
-    SOCKET_LOG(("poll timeout: %" PRIu32 "\n", minR));
-    return PR_SecondsToInterval(minR);
+    SOCKET_LOG(("poll timeout: %" PRIu32 "\n", PR_IntervalToSeconds(minR)));
+    return minR;
 }
 
 int32_t
-nsSocketTransportService::Poll(uint32_t *interval,
-                               TimeDuration *pollDuration)
+nsSocketTransportService::Poll(TimeDuration *pollDuration)
 {
     PRPollDesc *pollList;
     uint32_t pollCount;
     PRIntervalTime pollTimeout;
     *pollDuration = 0;
 
     // If there are pending events for this thread then
     // DoPollIteration() should service the network without blocking.
     bool pendingEvents = false;
     mRawThread->HasPendingEvents(&pendingEvents);
 
+    PRIntervalTime ts = PR_IntervalNow();
+
     if (mPollList[0].fd) {
         mPollList[0].out_flags = 0;
         pollList = mPollList;
         pollCount = mActiveCount + 1;
-        pollTimeout = pendingEvents ? PR_INTERVAL_NO_WAIT : PollTimeout();
+        pollTimeout = pendingEvents ? PR_INTERVAL_NO_WAIT : PollTimeout(ts);
     }
     else {
         // no pollable event, so busy wait...
         pollCount = mActiveCount;
         if (pollCount)
             pollList = &mPollList[1];
         else
             pollList = nullptr;
         pollTimeout =
             pendingEvents ? PR_INTERVAL_NO_WAIT : PR_MillisecondsToInterval(25);
     }
 
-    PRIntervalTime ts = PR_IntervalNow();
-
     SOCKET_LOG(("    timeout = %i milliseconds\n",
          PR_IntervalToMilliseconds(pollTimeout)));
     int32_t rv = PR_Poll(pollList, pollCount, pollTimeout);
 
     PRIntervalTime passedInterval = PR_IntervalNow() - ts;
 
     SOCKET_LOG(("    ...returned after %i milliseconds\n",
          PR_IntervalToMilliseconds(passedInterval)));
 
-    *interval = PR_IntervalToSeconds(passedInterval);
     return rv;
 }
 
 //-----------------------------------------------------------------------------
 // xpcom api
 
 NS_IMPL_ISUPPORTS(nsSocketTransportService,
                   nsISocketTransportService,
@@ -1068,72 +1101,58 @@ nsSocketTransportService::DoPollIteratio
     // 30 active connections is the historic limit before firefox 7's 256. A few
     //  windows systems have troubles with the higher limit, so actively probe a
     // limit the first time we exceed 30.
     if ((mActiveCount > 30) && !mProbedMaxCount)
         ProbeMaxCount();
 #endif
 
     // Measures seconds spent while blocked on PR_Poll
-    uint32_t pollInterval = 0;
     int32_t n = 0;
     *pollDuration = 0;
+
     if (!gIOService->IsNetTearingDown()) {
         // Let's not do polling during shutdown.
 #if defined(XP_WIN)
         StartPolling();
 #endif
-        n = Poll(&pollInterval, pollDuration);
+        n = Poll(pollDuration);
 #if defined(XP_WIN)
         EndPolling();
 #endif
     }
 
+    PRIntervalTime now = PR_IntervalNow();
+
     if (n < 0) {
         SOCKET_LOG(("  PR_Poll error [%d] os error [%d]\n", PR_GetError(),
                     PR_GetOSError()));
     }
     else {
         //
         // service "active" sockets...
         //
         uint32_t numberOfOnSocketReadyCalls = 0;
         for (i=0; i<int32_t(mActiveCount); ++i) {
             PRPollDesc &desc = mPollList[i+1];
             SocketContext &s = mActiveList[i];
             if (n > 0 && desc.out_flags != 0) {
 #ifdef MOZ_TASK_TRACER
 		tasktracer::AutoSourceEvent taskTracerEvent(tasktracer::SourceEventType::SocketIO);
 #endif
-                s.mElapsedTime = 0;
+                s.StopTimeout();
                 s.mHandler->OnSocketReady(desc.fd, desc.out_flags);
                 numberOfOnSocketReadyCalls++;
-            }
-            // check for timeout errors unless disabled...
-            else if (s.mHandler->mPollTimeout != UINT16_MAX) {
-                // update elapsed time counter
-                // (NOTE: We explicitly cast UINT16_MAX to be an unsigned value
-                // here -- otherwise, some compilers will treat it as signed,
-                // which makes them fire signed/unsigned-comparison build
-                // warnings for the comparison against 'pollInterval'.)
-                if (MOZ_UNLIKELY(pollInterval >
-                                static_cast<uint32_t>(UINT16_MAX) -
-                                s.mElapsedTime))
-                    s.mElapsedTime = UINT16_MAX;
-                else
-                    s.mElapsedTime += uint16_t(pollInterval);
-                // check for timeout expiration
-                if (s.mElapsedTime >= s.mHandler->mPollTimeout) {
+            } else if (s.IsTimedOut(now)) {
 #ifdef MOZ_TASK_TRACER
-		    tasktracer::AutoSourceEvent taskTracerEvent(tasktracer::SourceEventType::SocketIO);
+		tasktracer::AutoSourceEvent taskTracerEvent(tasktracer::SourceEventType::SocketIO);
 #endif
-                    s.mElapsedTime = 0;
-                    s.mHandler->OnSocketReady(desc.fd, -1);
-                    numberOfOnSocketReadyCalls++;
-                }
+                s.StopTimeout();
+                s.mHandler->OnSocketReady(desc.fd, -1);
+                numberOfOnSocketReadyCalls++;
             }
         }
 
         // check for "dead" sockets and remove them (need to do this in
         // reverse order obviously).
         //
         for (i=mActiveCount-1; i>=0; --i) {
             if (NS_FAILED(mActiveList[i].mHandler->mCondition))
diff --git a/netwerk/base/nsSocketTransportService2.h b/netwerk/base/nsSocketTransportService2.h
--- a/netwerk/base/nsSocketTransportService2.h
+++ b/netwerk/base/nsSocketTransportService2.h
@@ -173,17 +173,23 @@ private:
     //
     // where k=0,1,2,...
     //-------------------------------------------------------------------------
 
     struct SocketContext
     {
         PRFileDesc       *mFD;
         nsASocketHandler *mHandler;
-        uint16_t          mElapsedTime;  // time elapsed w/o activity
+        PRIntervalTime    mPollStartEpoch;  // time we started to poll this socket
+
+    public:
+        bool IsTimedOut(PRIntervalTime now) const;
+        void StartTimeout();
+        void StopTimeout();
+        PRIntervalTime TimeoutIn(PRIntervalTime now) const;
     };
 
     SocketContext *mActiveList;                   /* mListSize entries */
     SocketContext *mIdleList;                     /* mListSize entries */
     nsIThread     *mRawThread;
 
     uint32_t mActiveListSize;
     uint32_t mIdleListSize;
@@ -209,21 +215,20 @@ private:
     // poll list (socket thread only)
     //
     // first element of the poll list is mPollableEvent (or null if the pollable
     // event cannot be created).
     //-------------------------------------------------------------------------
 
     PRPollDesc *mPollList;                        /* mListSize + 1 entries */
 
-    PRIntervalTime PollTimeout();            // computes ideal poll timeout
+    PRIntervalTime PollTimeout(PRIntervalTime now); // computes ideal poll timeout
     nsresult       DoPollIteration(TimeDuration *pollDuration);
                                              // perfoms a single poll iteration
-    int32_t        Poll(uint32_t *interval,
-                        TimeDuration *pollDuration);
+    int32_t        Poll(TimeDuration *pollDuration);
                                              // calls PR_Poll.  the out param
                                              // interval indicates the poll
                                              // duration in seconds.
                                              // pollDuration is used only for
                                              // telemetry
 
     //-------------------------------------------------------------------------
     // pending socket queue - see NotifyWhenCanAttachSocket
