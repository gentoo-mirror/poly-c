# HG changeset patch
# User Kershaw Chang <kershaw@mozilla.com>
# Date 1585224513 0
# Node ID 5c838bd7129c61defb7a4a375bf2f02b2cfbd17f
# Parent  193f1506d257220601489ad90e6c9164cefef4d6
Bug 1607221 - Make mTimeouts protected by a lock r=dragana

Differential Revision: https://phabricator.services.mozilla.com/D68018

diff --git a/netwerk/base/nsSocketTransport2.cpp b/netwerk/base/nsSocketTransport2.cpp
--- a/netwerk/base/nsSocketTransport2.cpp
+++ b/netwerk/base/nsSocketTransport2.cpp
@@ -965,27 +965,27 @@ nsSocketTransport::InitWithConnectedSock
         port = addr->inet6.port;
     else
         port = 0;
     mPort = ntohs(port);
 
     memcpy(&mNetAddr, addr, sizeof(NetAddr));
 
     mPollFlags = (PR_POLL_READ | PR_POLL_WRITE | PR_POLL_EXCEPT);
-    mPollTimeout = mTimeouts[TIMEOUT_READ_WRITE];
     mState = STATE_TRANSFERRING;
     SetSocketName(fd);
     mNetAddrIsSet = true;
 
     {
         MutexAutoLock lock(mLock);
 
         mFD = fd;
         mFDref = 1;
         mFDconnected = 1;
+        mPollTimeout = mTimeouts[TIMEOUT_READ_WRITE];
     }
 
     // make sure new socket is non-blocking
     PRSocketOptionData opt;
     opt.option = PR_SockOpt_Nonblocking;
     opt.value.non_blocking = true;
     PR_SetSocketOption(fd, &opt);
 
@@ -1458,21 +1458,21 @@ nsSocketTransport::InitiateSocket()
 
     // assign mFD so that we can properly handle OnSocketDetached before we've
     // established a connection.
     {
         MutexAutoLock lock(mLock);
         mFD = fd;
         mFDref = 1;
         mFDconnected = false;
+        mPollTimeout = mTimeouts[TIMEOUT_CONNECT];
     }
 
     SOCKET_LOG(("  advancing to STATE_CONNECTING\n"));
     mState = STATE_CONNECTING;
-    mPollTimeout = mTimeouts[TIMEOUT_CONNECT];
     SendStatus(NS_NET_STATUS_CONNECTING_TO);
 
     if (SOCKET_LOG_ENABLED()) {
         char buf[kNetAddrMaxCStrBufSize];
         NetAddrToString(&mNetAddr, buf, sizeof(buf));
         SOCKET_LOG(("  trying address: %s\n", buf));
     }
 
@@ -1827,17 +1827,16 @@ nsSocketTransport::OnMsgOutputClosed(nsr
 
 void
 nsSocketTransport::OnSocketConnected()
 {
     MOZ_ASSERT(OnSocketThread(), "not on socket thread");
     SOCKET_LOG(("  advancing to STATE_TRANSFERRING\n"));
 
     mPollFlags = (PR_POLL_READ | PR_POLL_WRITE | PR_POLL_EXCEPT);
-    mPollTimeout = mTimeouts[TIMEOUT_READ_WRITE];
     mState = STATE_TRANSFERRING;
 
     // Set the m*AddrIsSet flags only when state has reached TRANSFERRING
     // because we need to make sure its value does not change due to failover
     mNetAddrIsSet = true;
 
     if (mFDFastOpenInProgress && mFastOpenCallback) {
         // mFastOpenCallback can be null when for example h2 is negotiated on
@@ -1851,16 +1850,17 @@ nsSocketTransport::OnSocketConnected()
     // to trample over mFDref if mFD is already set.
     {
         MutexAutoLock lock(mLock);
         NS_ASSERTION(mFD.IsInitialized(), "no socket");
         NS_ASSERTION(mFDref == 1, "wrong socket ref count");
         SetSocketName(mFD);
         mFDconnected = true;
         mFDFastOpenInProgress = false;
+        mPollTimeout = mTimeouts[TIMEOUT_READ_WRITE];
     }
 
     // Ensure keepalive is configured correctly if previously enabled.
     if (mKeepaliveEnabled) {
         nsresult rv = SetKeepaliveEnabledInternal(true);
         if (NS_WARN_IF(NS_FAILED(rv))) {
             SOCKET_LOG(("  SetKeepaliveEnabledInternal failed rv[0x%" PRIx32 "]",
                         static_cast<uint32_t>(rv)));
@@ -2072,18 +2072,22 @@ nsSocketTransport::OnSocketEvent(uint32_
         break;
 
     case MSG_OUTPUT_PENDING:
         SOCKET_LOG(("  MSG_OUTPUT_PENDING\n"));
         OnMsgOutputPending();
         break;
     case MSG_TIMEOUT_CHANGED:
         SOCKET_LOG(("  MSG_TIMEOUT_CHANGED\n"));
-        mPollTimeout = mTimeouts[(mState == STATE_TRANSFERRING)
-          ? TIMEOUT_READ_WRITE : TIMEOUT_CONNECT];
+        {
+          MutexAutoLock lock(mLock);
+          mPollTimeout =
+              mTimeouts[(mState == STATE_TRANSFERRING) ? TIMEOUT_READ_WRITE
+                                                       : TIMEOUT_CONNECT];
+        }
         break;
     default:
         SOCKET_LOG(("  unhandled event!\n"));
     }
 
     if (NS_FAILED(mCondition)) {
         SOCKET_LOG(("  after event [this=%p cond=%"  PRIx32 "]\n", this,
                     static_cast<uint32_t>(mCondition)));
@@ -2137,17 +2141,20 @@ nsSocketTransport::OnSocketReady(PRFileD
         // if waiting to read and socket is readable or hit an exception.
         if ((mPollFlags & PR_POLL_READ) && (outFlags & ~PR_POLL_WRITE)) {
             // assume that we won't need to poll any longer (the stream will
             // request that we poll again if it is still pending).
             mPollFlags &= ~PR_POLL_READ;
             mInput.OnSocketReady(NS_OK);
         }
         // Update poll timeout in case it was changed
-        mPollTimeout = mTimeouts[TIMEOUT_READ_WRITE];
+        {
+          MutexAutoLock lock(mLock);
+          mPollTimeout = mTimeouts[TIMEOUT_READ_WRITE];
+        }
     }
     else if ((mState == STATE_CONNECTING) && !gIOService->IsNetTearingDown()) {
         // We do not need to do PR_ConnectContinue when we are already
         // shutting down.
 
         PRStatus status = PR_ConnectContinue(fd, outFlags);
 
 #if defined(_WIN64) && defined(WIN95)
@@ -2181,17 +2188,20 @@ nsSocketTransport::OnSocketReady(PRFileD
 #endif
             //
             // If the connect is still not ready, then continue polling...
             //
             if ((PR_WOULD_BLOCK_ERROR == code) || (PR_IN_PROGRESS_ERROR == code)) {
                 // Set up the select flags for connect...
                 mPollFlags = (PR_POLL_EXCEPT | PR_POLL_WRITE);
                 // Update poll timeout in case it was changed
-                mPollTimeout = mTimeouts[TIMEOUT_CONNECT];
+                {
+                  MutexAutoLock lock(mLock);
+                  mPollTimeout = mTimeouts[TIMEOUT_CONNECT];
+                }
             }
             //
             // The SOCKS proxy rejected our request. Find out why.
             //
             else if (PR_UNKNOWN_ERROR == code &&
                      mProxyTransparent &&
                      !mProxyHost.IsEmpty()) {
                 code = PR_GetOSError();
@@ -2716,29 +2726,33 @@ nsSocketTransport::GetScriptableSelfAddr
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSocketTransport::GetTimeout(uint32_t type, uint32_t *value)
 {
     NS_ENSURE_ARG_MAX(type, nsISocketTransport::TIMEOUT_READ_WRITE);
+    MutexAutoLock lock(mLock);
     *value = (uint32_t) mTimeouts[type];
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSocketTransport::SetTimeout(uint32_t type, uint32_t value)
 {
     NS_ENSURE_ARG_MAX(type, nsISocketTransport::TIMEOUT_READ_WRITE);
 
     SOCKET_LOG(("nsSocketTransport::SetTimeout %p type=%u, value=%u", this, type, value));
 
     // truncate overly large timeout values.
-    mTimeouts[type] = (uint16_t) std::min<uint32_t>(value, UINT16_MAX);
+    {
+      MutexAutoLock lock(mLock);
+      mTimeouts[type] = (uint16_t)std::min<uint32_t>(value, UINT16_MAX);
+    }
     PostEvent(MSG_TIMEOUT_CHANGED);
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSocketTransport::SetReuseAddrPort(bool reuseAddrPort)
 {
   mReuseAddrPort = reuseAddrPort;
diff --git a/netwerk/base/nsSocketTransport2.h b/netwerk/base/nsSocketTransport2.h
--- a/netwerk/base/nsSocketTransport2.h
+++ b/netwerk/base/nsSocketTransport2.h
@@ -384,17 +384,17 @@ private:
     nsCOMPtr<nsISupports>           mSecInfo;
 
     nsSocketInputStream  mInput;
     nsSocketOutputStream mOutput;
 
     friend class nsSocketInputStream;
     friend class nsSocketOutputStream;
 
-    // socket timeouts are not protected by any lock.
+    // socket timeouts are protected by mLock.
     uint16_t mTimeouts[2];
 
     // QoS setting for socket
     uint8_t mQoSBits;
 
     //
     // mFD access methods: called with mLock held.
     //

