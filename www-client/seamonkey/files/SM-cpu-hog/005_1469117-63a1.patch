# HG changeset patch
# User Honza Bambas <honzab.moz@firemni.cz>
# Date 1534862032 0
# Node ID e28a399f05e8d7295955f2ce79484e64421427b5
# Parent  a61ce0335382e0d5cef5c0dd449ec15291554990
Bug 1469117 - Make sure we reset network socket timeout epoch to 0 when timeout on a socket is turned off r=dragana

Differential Revision: https://phabricator.services.mozilla.com/D3880

diff --git a/netwerk/base/nsSocketTransportService2.cpp b/netwerk/base/nsSocketTransportService2.cpp
--- a/netwerk/base/nsSocketTransportService2.cpp
+++ b/netwerk/base/nsSocketTransportService2.cpp
@@ -106,16 +106,24 @@ nsSocketTransportService::SocketContext:
     if (elapsed >= timeout) {
         SOCKET_LOG(("  timed out!"));
         return 0;
     }
     SOCKET_LOG(("  remains %us", PR_IntervalToSeconds(timeout - elapsed)));
     return timeout - elapsed;
 }
 
+void
+nsSocketTransportService::SocketContext::MaybeResetEpoch()
+{
+  if (mPollStartEpoch && mHandler->mPollTimeout == UINT16_MAX) {
+    mPollStartEpoch = 0;
+  }
+}
+
 //-----------------------------------------------------------------------------
 // ctor/dtor (called on the main/UI thread by the service manager)
 
 nsSocketTransportService::nsSocketTransportService()
     : mThread(nullptr)
     , mLock("nsSocketTransportService::mLock")
     , mInitialized(false)
     , mShuttingDown(false)
@@ -1156,16 +1164,18 @@ nsSocketTransportService::DoPollIteratio
             } else if (s.IsTimedOut(now)) {
 #ifdef MOZ_TASK_TRACER
 		tasktracer::AutoSourceEvent taskTracerEvent(tasktracer::SourceEventType::SocketIO);
 #endif
                 SOCKET_LOG(("socket %p timed out", s.mHandler));
                 s.DisengageTimeout();
                 s.mHandler->OnSocketReady(desc.fd, -1);
                 numberOfOnSocketReadyCalls++;
+            } else {
+                s.MaybeResetEpoch();
             }
         }
 
         // check for "dead" sockets and remove them (need to do this in
         // reverse order obviously).
         //
         for (i=mActiveCount-1; i>=0; --i) {
             if (NS_FAILED(mActiveList[i].mHandler->mCondition))
diff --git a/netwerk/base/nsSocketTransportService2.h b/netwerk/base/nsSocketTransportService2.h
--- a/netwerk/base/nsSocketTransportService2.h
+++ b/netwerk/base/nsSocketTransportService2.h
@@ -190,16 +190,20 @@ private:
         void EnsureTimeout(PRIntervalTime now);
         // Called after an event on a socket has been signalled to turn of the
         // timeout calculation.
         void DisengageTimeout();
         // Returns the number of intervals this socket is about to timeout in,
         // or 0 (zero) when it has already timed out.  Returns NS_SOCKET_POLL_TIMEOUT
         // when there is no timeout set on the socket.
         PRIntervalTime TimeoutIn(PRIntervalTime now) const;
+        // When a socket timeout is reset and later set again, it may happen
+        // that mPollStartEpoch is not reset in between.  We have to manually
+        // call this on every iteration over sockets to ensure the epoch reset.
+        void MaybeResetEpoch();
     };
 
     SocketContext *mActiveList;                   /* mListSize entries */
     SocketContext *mIdleList;                     /* mListSize entries */
     nsIThread     *mRawThread;
 
     uint32_t mActiveListSize;
     uint32_t mIdleListSize;
